1. ordered use_nl(c), use_hash(t), leading(o c t) use_nl(c) use_hash(i)
   1. from 절에 나열한 순으로 조인하고자 할때 ordered, 
   2. 주문, 고객, 결제방식 순으로 조인하도록 할때 leading
2. force order, Loop join
3. ```
    SELECT o.주문번호, o.고객번호, c.고객명, c.전화번호, o.주문금액, t.결제방식명
    FROM 주문 o
        inner loop join 고객 c on(c.고객번호 = o.고객번호)
        inner loop join 결제방식 t on (t.결제방식코드 = o.결제방식코드)
    where o.주문일자 >= trunc(sysdate)
    option (force order)
    ```
   1. from절에 테이블을 나열한 순으로 조인하고자 할때 force roder 힌트를 사용함
   2. NL조인으로 유도할 때 inner join구분을 사용하며, 해시조인으로 유도할 때 inner hash join구문을 사용
4. 2
   1. 먼저 use_nl을 사용함으로 사원을 고객테이블에 조인
   2. e 인덱스 먼저 사용후 c인덱스 사용이라고 되어잇으므로 인덱스로 따짐
   3. e인덱스는 입사일자로 가져오는 인덱스로 엑세스 근데 부서코드에 인덱스가 없으므로 입사일자로 엑세스한 rowid로 부서코드를 가져옴
   4. c인덱스로 사원번호와 관리사원의 인덱스가 없으므로 고객번호 인덱스로 가져온rowid로 관리사원번호와 최종주문금액을 만듬
   5. 결론적으로 옵티마이저 입장에서 인덱스를 사용해서 입사일자와 입사일자 인덱스로 rowid를 이용 그리고 고객번호 rowid를 이용한 관리사원번호 조회후 사원번호와 조인함, 그후 최종주문금액을 수행함
5. 1
   1. use_nl(c)을 사용하므로 통상 e를 c로 loop join하라는 뜻으로 됨
   2. 고로 나, 다로 시작을 할텐데 각각 사원 x1 사원 x2를 탐색함 따라서 2,3,4는 해당이 안되므로 답은 1이됨
6. 2
   1. 4
   2. 부분범위처리가 효과적일때도 유리하고, 부분범위처리가 불가능할때 소량일때도 유리하다.
7. 3
   1. 가장 효과적인 방안을 따졌을때는 상품 인덱스를 이용한 액세스 row를 줄이는 순서가 가장 중요하다는 생각이 듬
   2. 상품테이블의 대한 랜덤엑세스 가 많은 것이 문제이기 때문에 인덱스를 늘려 랜덤액세스를 줄인다.
8. 1
   1. 인덱스 스캔효율이 매우 좋지않고, 조건절의 순서에 맞게 하는 것이 효율이 좋을것이므로 인덱스 순서를 바꿔서 스캔효율을 높여줌
   2. 2,3번은 추가 인덱스 필요가 없음
   3. 거래 x01은 시작인댁스가 거래일자이므로 상품코드 먼저나오는 입장에서 스캔 효율이 매우 안좋아 질 것임
9. 3
   1.  블록 두개 69개 로우를 가져오므로 효율에는 문제없음
   2.  추가로 필터링되는 컬럼이없으므로 역시 문제없음
   3.  일단 인덱스 구성으로만보면 거래 01을 쓰고 거래일자가 상품코드 다음으로 필터링하므로 효율에는 ㅁ누제가있고 그걸 25257개의 블록수를 가져오는걸로 보여준다, 따라서 거래 01에서 02로 바꾸는 것은 검토가 필요하다고 판단, 거래 02는 그리고 상품코드 + 거래일자로 구성되어있어서 조회조건 기준에서는 인덱스 효율이 좋을것
   4.  nl에서 효율을 찾은 후 답이안나올때 해시조인으로
10. 4
    1.  1번은 인덱스 컬럼순서에는 문제가 없다
    2.  2번도 인덱스 컬럼 갯수에 문제가 없다
    3.  거래쪽으로 35000번 조인과정에서 10만개 가까이 블록을 일금 조인과정에서 발생하는 io가 91퍼를 차지하는데 조인순서를 변경해볼수는 있으나, 평균거래가 10만건이므로 순서를 변경해도 io는 더 늘어날것임
    4.  인덱스가 모두 최적인 상황에서 조인순서를 변경해도 좋은 성능을 기대하기 힘들다면 다른 조인 메소드를 고려해야함
    5.  해시조인으로 유도하면 거래테이블은 거래_X02 인덱스를 통해 액세스하게 됨. 이 인덱스의 클래스터링 팩터가 성능을 좌우하겠지만, 최악의 경우를 가정해도 io 발생량이 많이 줄것임
11. 4
    1.  1,2,3 SALE_GRP_ID, STRD_ID둘다 인덱스 구성에는 필요하겠지만 테이블상으로는 필요한 인덱스가 아님
    2.  따라서 SALE_ORG_ID와 STC_DT만 해당됨
12. 4
    1.  STC_DT역순으로 정렬한 결과집합 중 상위 10개만 아주 빠르게 출력할 수 있도록 인덱스를 구성
    2.  부분범위 처리가 가능하고 NL방식 조인에 최적화되도록 인덱스를 구성해야함
    3.  소트연산을 생략하려면 드라이빙 테이블인 PRA_HST_STC의 인덱스를 SALE_ORG_ID + STC_DT 순으로 구성해야함
    4.  NL조인을 효과적으로 처리하려면 Inner 쪽 테이블인 ODM_TRMS의 인덱스를 STRD_GRP_ID + STRD_ID + TRMS_DT 또는 STRD_ID + STRD_GRP+ID + TRMNS_DT 순으로 구성해야됨
13. 3
    1.  인덱스 컬럼을 앞에 두나 뒤로두나 상관없음
    2.  일반절 분포중 범위분포보다 =분포가 더 나을 수 있으ㅡ로 _dt가 나중에 오는 컬럼이 낭르것
    3.  따라서 x2, x3이 최적 둘의 성능차이는 없음
    4. = 조건이 아닐때는 데이터 분포에 따라 유불리가 결정됨
 14. 3
     1.  use_nl, index(p), index(t)
     2.  outer쪽 테이블 access가 nl인 실행계획은 나올 수 없음
 15. 
    1. 문제점
       1. 할부계획의 할부개월수는 서비스별할부의 일할계산여부가 'Y'가 아닐 때만 필요한데, 일할 계산여부가 'Y'일 때도 조인을 수행하고 있다.
    2. 튜닝 방안
      서비스별할부의 일할계산여부가 'Y'가 아닐 때만 조인하도록 조건절을 아래와 같이 수정함 으로써 조인 일량을 최소화한다.
   ```
      SELECT ...
      (SELECT CASE WHEN A. 일할계산여부 = 'Y'
      THEN NVL(A. 총청구건수, 0) - NVL(A. 청구횟수, 0)
      ELSE B. 할부개월수 - NVL(A.청구횟수, 0) END
      FRON 서비스별할부 A, 할부계획 B WHERE A.서비스계약번호 = MV.서비스계약번호
      AND A.할부상태코드 = 'XR'
      AND B. 할부계획ID(+)= (CASE WHEN A. 일할계산여부 = 'Y'
      THEN NULL
      ELSE A.할부계획 ID END)
      AND RONNUM 《 1) AS 청구횟수, ...
   ```
16. 3
    1.  from절에 나열한 순으로 조인하려고 할때 ordered힌트사용
    2.  주문 고객 힌트순으로 명시하고자 할때 leading힌트인자에 테이블 별칭 명시
    3.  소트머지 조인으로 유도할때 use_merge 힌트 사용
    4.  merge 힌트는 뷰머징유도, sort_merge는 없음
17. force order merge join
    1.  테이블나열한 순으로 조인할 때 force order
    2.  소트머지조인으로 유도할때 merge join
18. leading(d) use_merge(e)
    1.  d를 먼저읽고 emp 조인이므로 ordered 힌트를 사용하려면 from을 수정해야됨
    2.  따라서 leading으로 dept를 먼저읽고 머지조인으로 유도한다.
19. 3
    1.  조인을 위해 실시간으로 인덱스를 생성
    2.  pGA에 저장된 데이터를 이용하기 때문에 빠름
    3.  소트부하만 감수하면 NL조인보다 빠를 수 있음
    4.  조인컬럼 인덱스 유무에 영향을 받지 않음
    5.  스캔 위주의 액세스 방식을 사용함
20. 2
    1.  SORT AREA에서 가져오는 개념
    2.  소트머지조인은 조인대상집합을 일괄로 읽어 PGA에 저장한 후 조인함
    3.  PGA는 프로세스만을 위한 독립적인 메모리 공간이므로 데이터를 읽을 때 래티 획득 과정이 없음
    4.  소트머지조인이 대량 데이터 조인에 유리한 이유임
21. 3
    1.  소트머지조인은 pga의 access제외하면 nl조인과 다를게 없음 따라서 =조건일때만 사용가능한 해시조인과 비교가 됨
    2.  소트머지조인은 pga access가 있기 때문에 메모리를 많이 사용함
    3.  temp 테이블스페이스 또한 많이 사용함
    4.  양쪽집합이 대용량일 때 해시조인이 더 빠름
22. 4
    1.  작은 테이블을 읽고 맵을 생성하고 큰 테이블을 탐색
23. 2
    1.  emp를 build input으로 사용하는 힌트를 찾는다
    2.  leading이나 ordered로 첫번째로 명시된 테이블이 build input
24. hash join
25. 4
    1.  nl 소트머지 해시 순으로 느림
    2.  해시조인도 pga에 생성해둔해시테이블을 탐색하면서 조인한다는 점이 다름
    3.  인덱스 가 없어도 상관없음
26. 3
    1.  소트머지조인은 먼저 사전에 PGA로 테이블을 다 읽어내는 작업을 먼저함
    2.  이때 해시조인은 작은 테이블을 읽어 해시를 만들고 큰 테이블을 액세스하는 작업을 진행하므로 만약 테이블의 규모가 작다면 굳이 temp 테이블스페이스까지 영향이 없을 것임
27. 2
    1.  상품코드보다 판매일자의 컬럼분포도가 더 적을 수도 있음
        1.  그리고 현재 인덱스도 300만건중 9만건 을 필터링한 결과로 봤을떄 효율이 나쁜편은 아님
    2.  대리점을 먼저 읽은 후 조인하면 1000번의 조인 액세스가 발생하고 쿼리의 결과도 해당 상품코드를 판매한 대리점이 30건밖에 없는걸로 효율이 좋다고 할 수 없음
    3.  쿼리를 아래처럼 수정하면 Group by로 인해 대리점 코드의 조인액세스를 대리점 코드별로 1번만 할 수 있어 성능개선에 도움이 됨
                 ```
            SELECT A. 대리점명, B. 판매금액
            FROM 대리점 A
               (SELECT 1*+ NO_MERGE */ 대리점코드, SUM(판매금액) 판매금액

               FROM 상품판매실적

               RHERE 상품코드 IN ('A1847', '20413' )
               AND
               판매일자 BETWEEN 20210101' AND 20210331'

               GROUP BY 대리점코드) B
               WHERE A. 대리점코드 = B. 대리점코드
            ```

     4. 1000 로우를 가진 대리점 테이블로 해시맙을 만들어 조인하므로 SGA 버퍼 캐시를 반복해서 탐색하는 비효율을 제거할 수 있틍ㅁ
28. 4
    1.  =조건으로 바꾸면 substr을 사용한 조건절이어도 해당 구성으로 해시맵을 구성할 수 있게 됨
29. 3
    1.  수행빈도가 높은 쿼리는 계속해서 메모리와 CPU를 사용하게 됨
    2.  따라서 수행빈도가 낮고 대량의 조회할 때 해시조인으로 유도하는 편이 좋음
30. 2
    1.  29번과 같음
31. 2
    1.  NL조인은 드라이빙 집합에 의해 전체 일량이 결정되므로 순서가 매우 중요함
    2.  해시는 hash area에 build input을 모두 채울 수 있느냐가 관건이므로 작은쪽을 먼저 조인하는게 중요함
    3.  소트머지조인도 조인순서에 영향은 있지만 NL 이나 해시만큼 차이는 없음
32. leading(a,b,c) use_hash(b) use_hash(c) swap_join_inputs(c)
    1.  a는 기본적으로 build input이지만 leading에 먼저 기술되어있으므로 생략 가능함
33. leading(a,b,c) use_hash(b) use_hash(c) no_swap_join_inputs(c)
    1.  probe input을 명시적으로 선택할때 no_swap_join_inputs 힌트를 사용함
34. leading(c,b,a) hash(b) hash(a) swap_join_inputs(a)
    1.  상품과 주문상품 조인 후 주문을 build Input으로 사용하고 조인한다.
35. leading(c,b,a) use_hash(a) no_swap_join_input(a)
    1.  상품, 주문상품을 조인 후 해당 조인컬럼으로 주문과 해시조인함
36. /*+ leading(b a c d) use_hash(a) use_ni(c) use _hash(d) swap _join_inputs(d) index(b 가입상품_X1) index(a 계약 X1) index(c 가입부가상품_PK) index(d 상품_PK)*/
    1.  먼저 조인순서는 가입과 계약을 해시조인 -> 나온결과를 가입부가상품과 NL조인, 그후 상품과 다시 해시조인
    2.  leading은 bacd순으로 하고, swap_join_input는 생략할 수 있음
    3.  가입부가상품과는 nl이므로 use_nl(c)사용
37. 가입상품과 계약을 해시조인, 나온결과를 부가상품과 nl 조인, 나온결과를 상품과 해시조인
    1.  leading(b a d c), use_hash(a) use_hash(d) use_nl(c) no_swap_join_inputs(d)
    2.  index(b 가입상품_X1) index(a 계약_X1) index(c 가입부가상품_PK) inde(d 상품_PK)*
38. 3
    1.  ERD에서 주문과 결제구분간 관계썬을 보면 주문 레코드는 입력할 때 결제구분코드는 입력하지 않을 수 있다고 함 애초에 레퍼런스키가 아님
    2.  결제구분과 조인하는 스칼라서브쿼리를 일반 조인문으로 바꿀 때 Outer로 변환해줘야 함
    3.  고객번호는 이미 주문 고객번호와 조인하고 있기 때문에 필요없음
39. 4
    1.  max와 min을 구분하는 값으로 세팅 3과 4의 차이는 주문금액과 조인하는 고객명의 Max를 가져올 필요가 없음
40. 4
    1.  값이 적은 항목들에 대해서 조회시 성능 향상에 도움이됨
41. 3
    1.  건수가 적은 항목조회에 대해서 성능이 올라감 조인액세스를 5번밖에 안해도됨
42. 2
    1.  소트가 먼저 나올것이고 쿼리상으로 고객이 먼저 조인이 될것임 따라서 가장 가장자리에 마지막으로 조인되는 테이블은 거래테이블일 것이고 그이후에는 테이블, 인덱스 순으로 나타남
43. 모르겠음(다시확인)
44. 다시확인2 no_unnest를 사용하여 no_unnest를 입력
45. 1
    1.  지점코드에 대한 반복 액세스가 많은 쿼리임
    2.  다량의 판매내역을 읽으면서 적은 지점 테이블과 고인하기 때문에 생기는 현상임
        1.  1번의 판매지점, 지점코드를 서술은 무관함
        2.  2번의 지점테이블을 읽은 후 판매내역과 조인하마ㅕㄴ 조인액세스만 30번으로 줄일 수 있음
        3.  3번의 해시조인으로 유도하면 작은 지점 테이블로 PGA에 해시맵을 만들어 조인하게 되므로 SGA ㅂ버퍼 캐시를 반복적으로 탐색하는 비효율을 제거할 수 있음
        4.  ```
            SELECT A. 지점명, B.판매금액
            FROM 지점 A
            (SELECT*+ NO_MERGE */ 판매지점코드, SUM(판매금액) 판매금액
            FROM 판매내역
            WHERE 판매월 BETWEEN 202101' AND 202103'
            GROUP BY 판매지점코드) B WHERE A.지점코드 =B.판매지점코드
            ```
            아래와 같이 변환하면 조인액세스를 지점별로 한번씩만 할 수 있어 성능 개선에 도움이됨
            인라인뷰가 머징이 되면 쿼리가 원래형태로 돌아가므로 반드시 실행계획을 확인하고 no_merge 뷰로 merging을 방지해야함

46. 나, 라, 바/가 다 마 따라서 1
    1.  group by를 먼저하여 고객 c와 조인전 조인 부하를 줄이고, 나오는 값들을 고객 C 와 조인을해서 조인 횟수를 줄이는 역할을 한다 따라서 효과를 보려면 다 많은쪽으로 선택
47. 여기서부터 답지 정독함
```
SELECT /*LEADING(P) USE_HASH(0) INDEX(0 주문상품_X1) FULL(P)*/
       P.상품코드 , MIN(P.상품명) 상품명, MIN(P.상품가격) 상품가격
     , SUM(O.주문수량) 총주문수량, SUM(O.주문금액) 총주문금액
  FROM 주문상품 O, 상품 P
 WHERE O.주문일시 >= ADD_MONTH(SYSDATE, -1)
   AND O.할인유형코드 = 'K890'
   AND P.상품코드 = O.상품코드
   GROUP BY P.상품코드
   ORDER BY 총주문금액 DESC, 상품코드
```
48. 답안
```
SELECT /*+ LEADING(O) USE_HASH(P) FULL(P) * - EE LEADING(P) USE_HASH(O) FULL(P)

P. 상품코드, P. 상품명, P.상품가격, 0. 총주문수량, 0.총주문금액

FROM (SELECT /*+ FULL(A) NO_MERGE */

상품코드, SUM(주문수량) 총주문수량, SUM(주문금액) 총주문금액

FROM
주문상품 A

WHERE
주문일시 >= ADD_MONTHS (SYSDATE, -1)

AND 할인유형코드 ='K890'

GROUP BY 상품코드) 0, 상품 P

WHERE P. 상품코드 = 0. 상품코드

ORDER BY 총주문금액 DESC, 상품코드
```
49. 
    1.  테이블 = 월단위 파티션
    2.  월 100만건중 K890로 조회되는 데이터는 20만건임 전체의 1/5이므로 랜덤액세스보다 full scan이 낫다
    3.  2만개 상품중 할인유형코드 K890조건으로 판매되는 상품은 100개
    4.  따라서 GROUP BY를 하면 100건이 나옴 즉 상품당 주문상품은 평균 2000개가 나와 GROUP BY를 먼저했을 때 조인횟수가 많이 감소될 것
    5.  아래 쿼리처럼 작성
    ```
        SELECT /** LEADING(O) USE_NL(P) *1
            P. 상품코드, P.상품명, P. 상품가격, 0. 총주문수량, 0.총주문금액
        FROM (SELECT /** FULL (A) NO_MERGE */
                    상품코드, SUM(주문수량) 총주문수량, SUM(주문금액) 총주문금액
                FROM
                    주문상품 A
                WHERE
                    주문일시 >= ADDMONTHS(SYSDATE, -1)
                  AND
                    할인유형코드 ='K890' GROUP BY 상품코드) O, 상품 P
        WHERE P. 상품코드 = O. 상품코드
       ORDER BY 총주문금액 DESC, 상품코드
    ```

50. .
    1.  아래 쿼리로 변경
    ```
        SELECT /*+ LEADING(O) USE_NL(P) */
                P 상품코드, P 상품명, P. 상품가격, 0. 총주문수량, 0.총주문금액
          FROM (SELECT /** FULL(A) */
                    상품코드, SUM(주문수량) 총주문수량, SUM(주문금액) 총주문금액

                 FROM
                      주문상품 A
                WHERE 주문일시 >= ADD_MONTHS(SYSDATE, -1)
                  AND 할인유형코드 ='K890'
                GROUP BY 상품코드
                ORDER BY 총주문금액 DESC, 상품코드) 0, 상품 P

        WHERE P. 상품코드 = 0.상품코드
          AND ROWNUM <= 100
        ORDER BY 총주문금액 DESC. 상품코드
    ```
    2. 49번과 유사
    3. full스캔으로 한달 주문상품으로 100만건 중 20만건이 할인유형코드 조건을 만족, 만족하는 조건의 상품의 GROUP BY를 이용하여 100건의 건수를 만들고 해당 서브쿼리를 테이블로 상품P와 nestloop 조인을 함

51. .
    1.  아래 쿼리로 변경
    ```
        SELECT /*+ LEADING(P) USE_NL(O) INDEX_DESC(P 상품_X1) */
                P. 상품코드, P. 상품명, P.등록일시, P.상품가격, P. 공급자ID , 0. 총주문수량, 0. 총주문금액
          FROM (SELECT /** NO MERGE PUSH_PRED INDEXA (A 주문상품_X2) *1
                        상품코드, SUM(주문수량) 총주문수량, SUM(주문금액) 총주문금액
                    FROM
                  주문상품 A
                WHERE 주문일시 >= ADD_MONTHS(SYSDATE, -1)
                    AND 할인유형코드 ='K890' GROUP BY 상품코드) O, 상품 P
            WHERE P.상품코드 = 0.상품코드
            ORDER BY P. 등록일시 DESC
    ```
    2. 결과집합의 일부만 출력이기 떄문에 부분범위 처리가 가능하고 이때 소트 연산을 생락할 수 있어야 함
    3. 등록일시가 선두인 상품인덱스를 역순으로 스캔하면서 주문 상품을 GROUP BY 집합과 NL조인 하면됨
    4. 튜닝 의도대로 하려면 NO_MERGE PUSH_PRED 힌트를 사용함
 52. .
    1. 아래 쿼리로 변경
     ```
     SELECT /*+ LEADING(O) USE_NL(P) NO_NLJ_BATCHING(P) */
            P. 상품코드, P. 상품명, B. 등록일시, P.상품가격, P.공급자ID , 0. 총주문수량, 0. 총주문금액
       FROM (
                SELECT /*+ FULL(A) INDEX_FFS(B) LEADING(B) USE_HASH(A) */
                    A. 상품코드, WIN(B. 등록일시) 등록일시 , SUM(A. 주문수량) 총주문수량, SUM(A.주문금액) 총주문금액
                 FROM
                     주문상품 A, 상품 B
                WHERE A.주문일시 〉= ADD_MONTHS(SYSDATE, -1)
                  AND A.할인유형코드 ='K890' AND B. 상품코드 = A.상품코드
                GROUP BY A. 상품코드 ORDER BY 등록일시 DESC) O, 상품 P
        WHERE P.상품코드 = 0. 상품코드
     ```
     - 부분범위 처리 활용
     - 등록일시 인덱스 역순
 53. .
     1.  문제에 제시된 쿼리는 아래처럼 짜면 된다.
     ```
        SELECT *
        FROM (
            SELECT 작업일련번호, 실제방문일자
              FROM 작업지시
             WHERE 작업자ID = :작업자ID
               AND 실제방문일자 >= trunc(add_month(sysdate, -1))
            order by 실제방문일자 desc 
        )
        where rownum <= 10
     ```
     2. 최적의 인덱스 구성은 작업자 ID, 실제방문일자
     3. 작업지시가 나머지 두 테이블과 배타적인 관계이므로 두 테이블과 outer 조인을 수행해야함
     4. 접수 구분은 작업지시의 개통접수번호와 장애접수번호 중 어느 쪽에 값이 입력됐는지 여부에 따라 구분해도 되고, 모범답안처럼 어느 테이블과 조인에 성공했는지 여부에 따라 구분해도 됨
     ```
        SELECT *
          FROM (
                SELECT /*+ ordered use_nl(b) use_nl(c) */
                       A.작업일련번호, A.실제방문일자
                     , NVL2(b.개통접수번호, '개통', '장애') 접수구분
                     , NVL2(b.개통접수번호, b.고객번호, c.고객번호) 고객번호
                     , NVL2(b.개통접수번호, b.주소, c.주소) 주소  
                 FROM 작업지시 a, 개통접수 b, 장애접수 c
                WHERE a.작업자ID = :작업자ID
                  AND a.실제방문일자 >= trunc(add_month(sysdate, -1))
                  AND b.개통접수번호(+) = a.개통접수번호
                  AND c.장애접수번호(+) = a.장애접수번호
                  ORDER BY a.실제방문일자 desc
               )
              WHERE rownum <= 10
      - 인덱스 구성
      작업지시_X1 : 작업자 ID + 실제방문일자
     ```
54. .
    1.  데이터를 모두 출력해야 하므로 부분범위 처리를 활용한 튜닝 기법은 고려하지 않아도 됨
    2.  작업지시가 나머지 두 테이블과 배타적 관계임을 나타낼 수 있음
    3.  제시한 발생규칙은 좀 더 구체적으로 개통건은 개통접수테이블과 장애건은 장애접수테이블과 관계를 갖는다고 할 수 있다
    4.  따라서 개통건과 장애접수건 조회건 합친값을 도출한다.
    ```
        SELECT x.작업일련번호, x.작업자ID, '개통' AS 작업구분, Y.고객번호, Y.주소
          from 작업지시 x, 개통접수 ,Y
        WHERE x.작업구분코드 = 'A'
          AND x.방문예정일자 = to_char(sysdate, 'yyyymmdd')
          AND y.개통접수번호 = x.접수번호
        union all
        SELECT x.작업일련번호, x.작업자ID, '개통' AS 작업구분, Y.고객번호, Y.주소
          from 작업지시 x, 개통접수 ,Y
        WHERE x.작업구분코드 = 'B'
          AND x.방문예정일자 = to_char(sysdate, 'yyyymmdd')
          AND y.개통접수번호 = x.접수번호
    ```
55. 아래 쿼리처럼 작성
    ```
        SELECT a.작업일련번호, a.작업자ID
             , decode(a.작업구분코드, 'A', '개통','장애') AS 작업구분
             , decode(a.작업구분코드, 'A', b.고객번호,c.고객번호) AS 고객번호
             , decode(a.작업구분코드, 'A', b.주소, c.주소) AS 주소
          FROM 작업지시 a, 개통접수 b, 장애접수 c
         WHERE a.방문예정일자 = to_char(sysdate, 'yyyymmdd')
           AND b.개통접수번호(+) = decode(a.작업구분코드, 'A', a.접수번호)
           AND c.장애접수번호(+) = decode(a.작업구분코드, 'B', a.접수번호)
    ```
    - 작성된 쿼리는 decode를 활용하여 null이 발생할 수 있는 상황을 만들지 않게 결과가 나오게끔 함
    - 먼저 방문예정일자가 오늘인 작업지시 데이터를 출력하는 쿼리이므로 기본 조회조건에 방문예정일자를 조회조건으로 넣는다
    - 그리고 개통접수, 장애접수 항목에 대해서 테이블간 관계가 없는 상황에서 쿼리를 만들어야 하기 떄문에 작업지시 테이블의 작업구분코드 항목을 이용해서 각각 조인을 시도하게 한다.
    - 추가로 Outer조인으로 decode문을 시도시 Null일경우는 조인을 시도하지 않음
56.  아래 쿼리처럼 작성
    ```
        SELECT a.작업일련번호, a.작업자ID
             , '개통' AS 작업구분
             , a.qq고객번호
             , decode(a.작업구분코드, 'A', b.주소, c.주소) AS 주소
          FROM 개통접수 b, 작업지시 a
         WHERE a.방문예정일자 >= trunc(sysdate)
           AND a.방문예정일자 < trunc(sysdate + 1)
           AND b.작업구분코드 = 'A'
           AND b.접수번호 = a.개통접수번호
        union all
        SELECT a.작업일련번호, a.작업자ID
             , '장애' AS 작업구분
             , a.고객번호
             , decode(a.작업구분코드, 'A', b.주소, c.주소) AS 주소
          FROM 개통접수 b, 작업지시 a
         WHERE a.방문예정일자 >= trunc(sysdate)
           AND a.방문예정일자 < trunc(sysdate + 1)
           AND b.작업구분코드 = 'B'
           AND b.접수번호 = a.장애접수번호
        작업지시 X1 : 작업구분코드 + 접수번호 (또는 접수번호 + 작업구분코드)
        개통접수_x1: 개통접수일시 
        장애접수_x1: 장애접수일시
    ```
    - 소량의 데이터의 결과집합이라면 NL조인으로 처리해야 유리하다
    - 개통 및 장애접수 테이블이 드라이빙 되도록 조인순서를 유도

57. 1안만 작성
    ```
        SELECT P.참여번호, P.상태코드 as 최종상태코드, H.변경일자 as 최종변경일자, H.변경순번 as 최종변경순번
          FROM 장비 P, 상태변경 H
         WHERE P.장비구분코드 = 'A001'
           AND N.장비번호 = P.장비번호
           AND (H.변경일자, P.변경순번) = 
                    (
                        SELECT 변경일자, 변경순번 FROM (
                                SELECT 변경일자, 변경순번 FROM 상태변경이력
                                 WHERE 장비번호 = P.장비번호
                                 ORDER BY 변경일자 DESC , 변경순번 DESC
                        )
                    WHERE ROWNUM<=1)
        ORDER BY P.장비번호
    ```
    - 먼저A001일때 데이터를 가져옴
    - 최종상태의 코드를 가져오기 위해 서브쿼리로  변경일자와 변경순번을 가장 최신 데이터를 조회하는 값을 가져온다.

58. 1안만 작성
    ```
        SELECT P,장비번호, P.장비명
             , P. 최종상태코드
             , H. 상태코드 AS 직전상태코드 
             , H. 변경일자 AS 직전변경일자
             , H. 변경순번 AS 직전변경순번
          FROM 장비 P, 상태변경이력 H 
         WHERE P. 장비구분코드 ='A001' 
           AND H. 장비번호 = P. 장비번호 
           AND (H.변경일자, H. 변경순번)=
                (SELECT 변경일자, 변경순번 FROM (
                    SELECT 변경일자, 변경순번
                      FROM 상태변경이력
                     WHERE 장비번호 = P. 장비번호
                       AND 변경일자 < P.최종상태변경일자
                     ORDER BY 변경일자 DESC, 변경순번 DESC)
                     WHERE ROWNUM <= 1
                 )
          ORDER BY P. 장비번호
    ```
    - a001 장비구분코드 조회
    - 변경일자 변경순번 가져올때 변경일자가 최종상태 변경일자보다 작아야함

59. .
    ```
    SELECT P. 장비번호, P. 장비명, H. 상태코드 AS 최종상태코드 
         , TO_CHAR(H. 유효시작일시,'YYYMWDD') AS 최종상태변경일자
      FROM 장비 P, 상태변경이력 H
     WHERE P. 장비구분코드 = 'A001'
       AND H. 장비번호 = P. 장비번호
       AND H.유효시작일시 <= SYSDATE
       AND H. 유효종료일시 >= SYSDATE
    ORDER BY P. 장비번호
    ```
60. 상태변경이력 = 선분이력, 변경이 발생한 시점 뿐 아니라 해당 이력이 유효했던 종료 시점을 같이 관리하는 방식임
    1.  선분이력에서 현재가 아닌 특정 시점 이력을 조회할 때는 =조건 사용이 안되며 아래와 같이 between 조건을 사용해야함
    2.  where : 기준시점 between 유효시작일시 and 유효종료일시
        ```
            SELECT P.장비번호, P. 장비명, P.최종상태코드
                 , TO_CHAR(P. 최종상태변경일시, 'YYYYMMDD') AS 최종변경일자
                 , H. 상태코드 AS 직전상태코드
                 , TO_CHAR(H. 유효시작일시, 'YYWMDD') AS 직전변경일자
              FROM 장비 P, 상태변경이력 H
             WHERE P. 장비구분코드 = 'A001
               AND H. 장비번호 = P. 장비번호
               AND H.유효시작일시 < P.최종상태변경일시
               AND H. 유효종료일시 >= P,최종상태변경일시 - 1/(60*60*24)
             ORDER BY P. 장비번호
        ```