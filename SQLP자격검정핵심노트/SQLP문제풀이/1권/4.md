1. ordered use_nl(c), use_hash(t), leading(o c t) use_nl(c) use_hash(i)
   1. from 절에 나열한 순으로 조인하고자 할때 ordered, 
   2. 주문, 고객, 결제방식 순으로 조인하도록 할때 leading
2. force order, Loop join
3. ```
    SELECT o.주문번호, o.고객번호, c.고객명, c.전화번호, o.주문금액, t.결제방식명
    FROM 주문 o
        inner loop join 고객 c on(c.고객번호 = o.고객번호)
        inner loop join 결제방식 t on (t.결제방식코드 = o.결제방식코드)
    where o.주문일자 >= trunc(sysdate)
    option (force order)
    ```
   1. from절에 테이블을 나열한 순으로 조인하고자 할때 force roder 힌트를 사용함
   2. NL조인으로 유도할 때 inner join구분을 사용하며, 해시조인으로 유도할 때 inner hash join구문을 사용
4. 2
   1. 먼저 use_nl을 사용함으로 사원을 고객테이블에 조인
   2. e 인덱스 먼저 사용후 c인덱스 사용이라고 되어잇으므로 인덱스로 따짐
   3. e인덱스는 입사일자로 가져오는 인덱스로 엑세스 근데 부서코드에 인덱스가 없으므로 입사일자로 엑세스한 rowid로 부서코드를 가져옴
   4. c인덱스로 사원번호와 관리사원의 인덱스가 없으므로 고객번호 인덱스로 가져온rowid로 관리사원번호와 최종주문금액을 만듬
   5. 결론적으로 옵티마이저 입장에서 인덱스를 사용해서 입사일자와 입사일자 인덱스로 rowid를 이용 그리고 고객번호 rowid를 이용한 관리사원번호 조회후 사원번호와 조인함, 그후 최종주문금액을 수행함
5. 1
   1. use_nl(c)을 사용하므로 통상 e를 c로 loop join하라는 뜻으로 됨
   2. 고로 나, 다로 시작을 할텐데 각각 사원 x1 사원 x2를 탐색함 따라서 2,3,4는 해당이 안되므로 답은 1이됨
6. 2
   1. 4
   2. 부분범위처리가 효과적일때도 유리하고, 부분범위처리가 불가능할때 소량일때도 유리하다.
7. 3
   1. 가장 효과적인 방안을 따졌을때는 상품 인덱스를 이용한 액세스 row를 줄이는 순서가 가장 중요하다는 생각이 듬
   2. 상품테이블의 대한 랜덤엑세스 가 많은 것이 문제이기 때문에 인덱스를 늘려 랜덤액세스를 줄인다.
8. 1
   1. 인덱스 스캔효율이 매우 좋지않고, 조건절의 순서에 맞게 하는 것이 효율이 좋을것이므로 인덱스 순서를 바꿔서 스캔효율을 높여줌
   2. 2,3번은 추가 인덱스 필요가 없음
   3. 거래 x01은 시작인댁스가 거래일자이므로 상품코드 먼저나오는 입장에서 스캔 효율이 매우 안좋아 질 것임
9. 3
   1.  블록 두개 69개 로우를 가져오므로 효율에는 문제없음
   2.  추가로 필터링되는 컬럼이없으므로 역시 문제없음
   3.  일단 인덱스 구성으로만보면 거래 01을 쓰고 거래일자가 상품코드 다음으로 필터링하므로 효율에는 ㅁ누제가있고 그걸 25257개의 블록수를 가져오는걸로 보여준다, 따라서 거래 01에서 02로 바꾸는 것은 검토가 필요하다고 판단, 거래 02는 그리고 상품코드 + 거래일자로 구성되어있어서 조회조건 기준에서는 인덱스 효율이 좋을것
   4.  nl에서 효율을 찾은 후 답이안나올때 해시조인으로
10. 4
    1.  1번은 인덱스 컬럼순서에는 문제가 없다
    2.  2번도 인덱스 컬럼 갯수에 문제가 없다
    3.  거래쪽으로 35000번 조인과정에서 10만개 가까이 블록을 일금 조인과정에서 발생하는 io가 91퍼를 차지하는데 조인순서를 변경해볼수는 있으나, 평균거래가 10만건이므로 순서를 변경해도 io는 더 늘어날것임
    4.  인덱스가 모두 최적인 상황에서 조인순서를 변경해도 좋은 성능을 기대하기 힘들다면 다른 조인 메소드를 고려해야함
    5.  해시조인으로 유도하면 거래테이블은 거래_X02 인덱스를 통해 액세스하게 됨. 이 인덱스의 클래스터링 팩터가 성능을 좌우하겠지만, 최악의 경우를 가정해도 io 발생량이 많이 줄것임
11. 4
    1.  1,2,3 SALE_GRP_ID, STRD_ID둘다 인덱스 구성에는 필요하겠지만 테이블상으로는 필요한 인덱스가 아님
    2.  따라서 SALE_ORG_ID와 STC_DT만 해당됨
12. 4
    1.  STC_DT역순으로 정렬한 결과집합 중 상위 10개만 아주 빠르게 출력할 수 있도록 인덱스를 구성
    2.  부분범위 처리가 가능하고 NL방식 조인에 최적화되도록 인덱스를 구성해야함
    3.  소트연산을 생략하려면 드라이빙 테이블인 PRA_HST_STC의 인덱스를 SALE_ORG_ID + STC_DT 순으로 구성해야함
    4.  NL조인을 효과적으로 처리하려면 Inner 쪽 테이블인 ODM_TRMS의 인덱스를 STRD_GRP_ID + STRD_ID + TRMS_DT 또는 STRD_ID + STRD_GRP+ID + TRMNS_DT 순으로 구성해야됨
13. 3
    1.  인덱스 컬럼을 앞에 두나 뒤로두나 상관없음
    2.  일반절 분포중 범위분포보다 =분포가 더 나을 수 있으ㅡ로 _dt가 나중에 오는 컬럼이 낭르것
    3.  따라서 x2, x3이 최적 둘의 성능차이는 없음
    4. = 조건이 아닐때는 데이터 분포에 따라 유불리가 결정됨
 14. 3
     1.  use_nl, index(p), index(t)
     2.  outer쪽 테이블 access가 nl인 실행계획은 나올 수 없음
 15. 
    1. 문제점
       1. 할부계획의 할부개월수는 서비스별할부의 일할계산여부가 'Y'가 아닐 때만 필요한데, 일할 계산여부가 'Y'일 때도 조인을 수행하고 있다.
    2. 튜닝 방안
      서비스별할부의 일할계산여부가 'Y'가 아닐 때만 조인하도록 조건절을 아래와 같이 수정함 으로써 조인 일량을 최소화한다.
   ```
      SELECT ...
      (SELECT CASE WHEN A. 일할계산여부 = 'Y'
      THEN NVL(A. 총청구건수, 0) - NVL(A. 청구횟수, 0)
      ELSE B. 할부개월수 - NVL(A.청구횟수, 0) END
      FRON 서비스별할부 A, 할부계획 B WHERE A.서비스계약번호 = MV.서비스계약번호
      AND A.할부상태코드 = 'XR'
      AND B. 할부계획ID(+)= (CASE WHEN A. 일할계산여부 = 'Y'
      THEN NULL
      ELSE A.할부계획 ID END)
      AND RONNUM 《 1) AS 청구횟수, ...
   ```
16. 3
    1.  from절에 나열한 순으로 조인하려고 할때 ordered힌트사용
    2.  주문 고객 힌트순으로 명시하고자 할때 leading힌트인자에 테이블 별칭 명시
    3.  소트머지 조인으로 유도할때 use_merge 힌트 사용
    4.  merge 힌트는 뷰머징유도, sort_merge는 없음
17. force order merge join
    1.  테이블나열한 순으로 조인할 때 force order
    2.  소트머지조인으로 유도할때 merge join
18. leading(d) use_merge(e)
    1.  d를 먼저읽고 emp 조인이므로 ordered 힌트를 사용하려면 from을 수정해야됨
    2.  따라서 leading으로 dept를 먼저읽고 머지조인으로 유도한다.
19. 3
    1.  조인을 위해 실시간으로 인덱스를 생성
    2.  pGA에 저장된 데이터를 이용하기 때문에 빠름
    3.  소트부하만 감수하면 NL조인보다 빠를 수 있음
    4.  조인컬럼 인덱스 유무에 영향을 받지 않음
    5.  스캔 위주의 액세스 방식을 사용함
20. 2
    1.  SORT AREA에서 가져오는 개념
    2.  소트머지조인은 조인대상집합을 일괄로 읽어 PGA에 저장한 후 조인함
    3.  PGA는 프로세스만을 위한 독립적인 메모리 공간이므로 데이터를 읽을 때 래티 획득 과정이 없음
    4.  소트머지조인이 대량 데이터 조인에 유리한 이유임
21. 3
    1.  소트머지조인은 pga의 access제외하면 nl조인과 다를게 없음 따라서 =조건일때만 사용가능한 해시조인과 비교가 됨
    2.  소트머지조인은 pga access가 있기 때문에 메모리를 많이 사용함
    3.  temp 테이블스페이스 또한 많이 사용함
    4.  양쪽집합이 대용량일 때 해시조인이 더 빠름
22. 4
    1.  작은 테이블을 읽고 맵을 생성하고 큰 테이블을 탐색
23. 2
    1.  emp를 build input으로 사용하는 힌트를 찾는다
    2.  leading이나 ordered로 첫번째로 명시된 테이블이 build input
24. hash join
25. 4
    1.  nl 소트머지 해시 순으로 느림
    2.  해시조인도 pga에 생성해둔해시테이블을 탐색하면서 조인한다는 점이 다름
    3.  인덱스 가 없어도 상관없음
26. 3
    1.  소트머지조인은 먼저 사전에 PGA로 테이블을 다 읽어내는 작업을 먼저함
    2.  이때 해시조인은 작은 테이블을 읽어 해시를 만들고 큰 테이블을 액세스하는 작업을 진행하므로 만약 테이블의 규모가 작다면 굳이 temp 테이블스페이스까지 영향이 없을 것임
27. 2
    1.  상품코드보다 판매일자의 컬럼분포도가 더 적을 수도 있음
        1.  그리고 현재 인덱스도 300만건중 9만건 을 필터링한 결과로 봤을떄 효율이 나쁜편은 아님
    2.  대리점을 먼저 읽은 후 조인하면 1000번의 조인 액세스가 발생하고 쿼리의 결과도 해당 상품코드를 판매한 대리점이 30건밖에 없는걸로 효율이 좋다고 할 수 없음
    3.  쿼리를 아래처럼 수정하면 Group by로 인해 대리점 코드의 조인액세스를 대리점 코드별로 1번만 할 수 있어 성능개선에 도움이 됨
                 ```
            SELECT A. 대리점명, B. 판매금액
            FROM 대리점 A
               (SELECT 1*+ NO_MERGE */ 대리점코드, SUM(판매금액) 판매금액

               FROM 상품판매실적

               RHERE 상품코드 IN ('A1847', '20413' )
               AND
               판매일자 BETWEEN 20210101' AND 20210331'

               GROUP BY 대리점코드) B
               WHERE A. 대리점코드 = B. 대리점코드
            ```

     4. 1000 로우를 가진 대리점 테이블로 해시맙을 만들어 조인하므로 SGA 버퍼 캐시를 반복해서 탐색하는 비효율을 제거할 수 있틍ㅁ
28. 4
    1.  =조건으로 바꾸면 substr을 사용한 조건절이어도 해당 구성으로 해시맵을 구성할 수 있게 됨
29. 3
    1.  수행빈도가 높은 쿼리는 계속해서 메모리와 CPU를 사용하게 됨
    2.  따라서 수행빈도가 낮고 대량의 조회할 때 해시조인으로 유도하는 편이 좋음
30. 2
    1.  29번과 같음