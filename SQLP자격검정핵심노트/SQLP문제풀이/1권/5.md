### 5.SQL 옵티마이저
1. 3
   1. 규칙기반은 통상 단순한규칙에 의해서만 움직임
   2. 비용기반도 내부적으로는 규칙이 존재함
2. 1
   1. 규칙기반 옵티마이저는 캐싱효과를 고려하지 않음 그리고 옵티마이저 인덱스 캐싱으로 일부 캐싱효과를 고려하도록 할 수 있음
3. 3
   1.  Query Transformer : 사용자로부터 전달받은 SOL을 그대로 최적화하지 않고 우선 최적화 에 유리한 형태로 변환을 시도한다.
   2.  • Estimator : 쿼리 오퍼레이션 각 단계의 선택도(Selectivity), 카디널리티(Cardinality), 비용(Cost)을 계산하고, 궁극적으로는 실행계획 전체에 대한 총 비용을 계산해 낸다.
   3.  Plan Generator : 하나의 리를 수행하는 데 있어, 후보군이 될만한 실행계획들을 생성 해 낸다.
4.  3
    1. 힌트 기술이 되면 힌트대로 유도됨
    2. 힌트로 부하가 발생하면 발생한 대로 도출함
5.  1
     1. 'Bind Variable Peeking'은 SOL이 첫 번째 수행될 때 함께 딸려 온 바인드 변수 값을 살 짝 훔쳐보고(peek), 그 값에 대한 컬럼 분포를 이용해 실행계획을 결정하는 기능
     2. 'Adaptive Cursor Sharing'은 처음 실행 시 특정 실행계획으로 실행했다가 바인드 변수에 다른 값이 입력됐을 때 예상보다 많은 I/0가 발생하면 다른 실행계획을 추가로 생성하고, 이후로 바인드 변수 값 분포에 따라 다른 실행계획을 선택적으로 사용하는 기능이다.
     3. 'Cardinality Feedback' 기능은 12c에서 'Statistics Feedback'으로 이름이 변경되었다. 이는 최초 실행계획을 수립할 때 추정했던 카디널리티와 실제 실행 과정에 읽 은 로우 수 간에 차이가 크다고 판단되면, 조정된 카디널리티 값을 어딘가에 저장해 두었다 가 다음번 실행 시에 그것을 사용함으로써 다른 실행계획이 수립되도록 하는 기능이다.
     4. 'Adaptive Plans'는 런타임에 실행계획을 변경하는 기능들을 포함한다. 대표 적인 기능 하나만 간단히 소개하면, 예를 들어 통계정보상 A와 B가 둘 다 작은 집합이라고 판단해서 옵티마이저가 NL 조인을 선택했는데, 실제 실행 과정에 먼저 읽은 A 집합에서 예 상보다 많은 로우가 반환되면 해시 방식으로 조인 메소드를 변경한다.
6. 1
   1. 테이블통계, 컬럼통계, 사용
   2. 버퍼캐시크기는 테이블 통계, 컬럼통계에 포함되지 않는다.
7. 4
   1. 2티어냐 3티어냐에 따라서 최적화목표가 달라질 수 있음
8. 4
   1. 네트워크 속도는 실행계획 생성시 영향이 없음
9. 4
   1.  옵티마이저가 항상 최적의 실행계획을 생성하지 못하는 이유
       1.  부족한 옵티마이징 팩터
           1.  인덱스, IOT, 클러스터링, 파티셔닝
       2.  부정확한 통계
           1.  정보 수집 및 보관 비용 측면의한계
       3.  결합 선택도 산정의 어려움
       4.  바인드 변수 사용 시 히스토그램 사용 제약
       5.  비현실적인 가정과 규칙에 의존
       6.  최저고하 시간에 허용된 시간 제약
   2.  라이브러리 캐시 공간의 크기는 옵티마이저가 생성하는 실행계획에는 영향을 주지 않음
10. 4/100000
    1.  카디널리티 = 총 로우수 * 선택도 = 총로우수 / NOV
    2.  총 레코드 수 / NDV = 100000/4 = 25000
11. 4/1000
12. 3
    1.  오라클이 수집하는 컬럼 통계 항목
        1. 중복을 제거한 컬럼 값의 수
        2. 최소값
        3. 최대값
        4. 밀도
        5. 평균 컬럼 길이
        6. NULL 값을 가진 레코드 수
     2. 컬럼 통계 수집 시 평균 컬럼 길이는 측정하지만, 최소 컬럼 길이와 최대 컬럼 길이는 측정하지 않음
13. 2
    1.  시스템통계는 애플리케이션 및 하드웨어 성능 측정을 측정한 것이며, 아래 항목들을 포함함
        1.  CPU 속도
        2.  평균적인 Single Block i/o 속도
        3.  평균적인 multiblock i/o 속도
        4.  평균적인 multiblock i/o 속도
        5.  i/o 서브시스템의 최대 처리량
        6.  병렬 Slave의 평균적인 처리량
    2.  평균적인 Single Block I/O 개수는 당연히 1이므로 수집하지 않음
    3.  Multiblock I/O 단위를 128
14. 3
    1. I/O 비용모델의 비용은 예상되는 블록 개수가 아니라 디스크 I/O Call 횟수임
    2. Single Block I/O일 때는 I/O Call 횟수가 읽은 블록 수와 일치하겠지만 Multiblock I/O 일 때는 읽은 블록수를 Multiblock I/O 단위로 나눈 만큼의 I/O call 이 발생함
15. 2
    1.  12c 이상버전에서 사용하는 히스톨그램
        1.  도수분표
        2.  높이균형
        3.  상위도수분포
        4.  하이브리드
    2.  2 : 넓이 균형 히스토그램은 없다
16. 4
    1.  인덱스를 이용한 테이브 ㄹ액세스 비용
        1.  비용 = 브랜치레벨 + (리프블록수 * 유효인덱스 선택도) + (클러스터링 팩터 * 유효 테이블 선택도)
    2.  유효 인덱스 선택도는 인덱스 총 레코드 중에서 조건절을 만족할 것으로 예상되는 레코드 비용을 의미함
    3.  유효 테이블 선택도는 전체 인덱스 레코드 중에서 인덱스 스캔을 완료하고서 테이블을 방문할 것으로 예상되는 레코드 비율을 의미함
17. ㄱ : 소프트파싱/ ㄴ : 하드파싱
18. 1
    1. 테이블 통계 인덱스 통계 컬럼 통계는 하드 파싱 과정에 수집하는 것이 아니라 DBA가 설정한 주기(보통 일 주 월 단위)에 따라 미리 수집해 둠
    2. 물론 다이나믹 샘플링이 필요한 상황이면 하드파싱 과정에 통계정보를 수집하기도 하지만, 이를 딕셔너리에 저장하지는 않음 
19. 2
    1. 라이브러리 캐시에서 SQL을 찾기 위해 사용하는 키 값이 'SQL'문 그 자체 이므로 문자 하나만 달라도 다른 SQL로 인식함 
20. 3
    1.  조건절에 상수 값을 사용하면 컬럼 히스토그램을 사용할 수 없어 SQL 최적화에 도움이 됨
    2.  반면 바인드 변수를 사용하면 컬럼 히스토그램을 사용하지 못하므로 상수 값을 사용할 때보다 다소 안 좋은 실행계획을 수립할 가능성이 있음
21. 2
    1.  open_cursors파라미터는 세션 당 open 할 수 있는 커서 개수를 제한하는 파라미터임
22. 3
23. 3
24. 3
25. 4
26. 3
27. 4
28. 4
29. no_unnest
    1.  필터사용 -> unnest하지 않았을때 나오는 쿼리
30. unnest nl_sj----> 여기까지함
    1.  unnesting했을때 실행계획이 서브쿼리가 존재하는 상태에서 nl조인이나, 소트머지, 해시조인 등으로 사용이 가능하다
    2.  SQL은 고객을 먼저 드라이빙함. 고객과 거래는 1:M관계이므로 그대로 조인하면 결과집합이 고객이 아닌 거래 단위의 집합으로 변함
    3.  그래서 세미 조인 방식을 사용
    4.  이는 outer 테이블의 한 로우가 inner 테이블의 한 로우와 조인에 성공하는 순간 진행을 멈추고 outer 테이블의 다음 로우가 Inner 테이블의 한 로우와 조인에 성공하는 순간 진행을 멈추고 Outer테이블의 다음 로우를 계쏙 처리하는 방식임
31. unnest(@subq) leading(거래@subq) use_nl(c)
    1. unnest시 나올수 있는 쿼리이며 이 쿼리에서 nl, 해시, 소트머지조인을 선택할수 있음
    2. 실행계획상에서 거래 테이블을 드라이빙으로 잡고 nl조인을 하는 식이기 때문에 unnest leading거래, use_nl순으로 작성한다
32. count절에 /*+ full(c)*/ 힌트를 넣는 형태의 쿼리
    1.  한번도 거래하지 않은 고객수를 조회하기 위해서 100만고객중 대부분 full scan으로 처리해야 함
    2.  다만 튜닝을 위해서 rownum조건을 뺴야되는데 unnesting하지않은 서브쿼리는 필터방식으로 처리해야 해서 unnesting이 불가능함
33. 다시확인할것
34. 2
    1. 고객과 NL하는 조인방식은 고객별 거래량이 많고 가입일시 조건을 만족하는 데이터가 많을수록 유리하다.
35. 