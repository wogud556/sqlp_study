1. 4
   1. 2
   2. 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미함
   3. 따라서 블록 첫번째 로우의 키 값과 일치하지 않을 수 없음
2. 4
   1. 1
   2. 테이블 스페이스는 ROWID 구조가 아님
3. 4
4. 2
   1. 4
   2. 가입일자 + 고객명을 선두로 갖는 인덱스가 없어 4번힌트는 무시됨
5. 3
   1. with 절 사용시 2,3번을 활용한다
   2. 클러스터형 인덱스가 없는 상황에서 index(0)을 지정하면 테이블 full scan 하면서 조건절을 필터링하며 index(1)을 지정하면 구문 오류가 발생함
6. 3
   1. 2
7. 2
   1. inde range scan 시 인덱스의 선두컬럼에 대한 조건이 반드시 있어야 하지만, '=' 조건일 필요는 없음, 부등호 BETWEEN LIKE등 모두 가능함
8. 2
   1. 4
   2. 오라클은 INDEX_FS 힌트를 제공하지 않음.
   3. index 힌트로 지정한 인덱스 선두 컬럼이 조건절에 없으면 INDEX FULL SCAN이 자동 선택되므로 별도 힌트가 필요하지 않음.
9.  4
    1.  2
    2.  PK 인덱스는 Unique함.
    3.  Unique 인덱스 구성 컬럼을 모두 = 조건으로 검색하면 index unique scan이 선택되지만 전체가 아닌 일부 컬럼으로 검색할 때는 Range scan이 선택됨
10. 4
    1.  1
    2.  인덱스 리프 블록들은 물리적으로는 여러 익스텐트에 흩어진 상태로 저장됨
    3.  하지만 정렬 순서에 따라 이중연결리스트(double linked list) 방식으로 서로 연결돼 있으므로 순서대로 스캔하면 결과 집합의 순서를 보장함
    4.  index full scan은 인덱스 리프 블록끼리의 논리적인 연결 순서를 따르지 않고
11. 1
    1.  2
    2.  조건절에 누락된 인덱스 선두 컬럼의 IN 조건절을 추가해주는 튜닝 기법과 용도는 비슷하지만 인덱스 스캔 원리는 다름
    3.  옵티마이저는 in 방식으로 강제로 처리할 수 없는 의미
12. 1
    1.  3
    2.  두 인덱스의 선투컬럼이 조건절에 없으므로 index range scan은 불가능함
    3.  인덱스에 없는 컬럼을 포함하므로 index fast full scan은 불가능함
13. 3
    1.  4
    2. 고객_PK를 사용하도록 힌트로 유도하면 고객번호가 조건절에 없으므로 index full scan하게 됨
    3. 고객_X01를 사용하면 선두컬럼인 연령이 조건절에 있으므로 index range scan이 가능함
    4. index skip scan도 가능하며, 고객 중 동명이인이 거의 없다면 range scan보다 skip scan이 유리함
    5. 즉 index range scan, index skip scan, index full scan 모두 가능함
14. 1
    1.  3
    2.  in 절에서 skipscan 이 안도는 이유
    3.  Skip Scan은 인덱스의 선두 컬럼에 대한 조건이 없을 때, 후행 컬럼 조건을 활용하여 인덱스를 반복적으로 탐색하는 방식입니다.
    4.  즉, 선두 컬럼이 없어도 후행 컬럼 조건을 이용해 “반복적으로 스캔”하는 방식(마치 선두 컬럼의 값들을 루프 돌리듯)

15. 4 -> 2,3
    1.  1
    2.  index  skew는 인덱스 엔트리가 왼쪽 또는 오른쪽으로 치우치는 현상
    3.  index sparse는 인덱스 블록 전반에 걸쳐 밀도가 떨어지는 현상을 말함
16. 1
    1.  2
    2.  비트맵 인덱스는 주로 읽기 위주의 대용량 DW환경에서 사용함
17. 3
    1.  조건절에서 인덱스 컬럼에 함수를 적용하면 정상적인 index range scan이 불가능함
    2.  인덱스에는 가공하지 않은 값을 기준으로 정렬해서 저장했는데, 가공한 값으로 검색하면 수직적 탐색을 통해 스캔 시작점과 끝 지점을 찾을 수 없기 때문임
    3.  아래 함수 기반 인덱스 생성시 문제 sql 도 index range scan이 가능함
18. 4
    1.  리버스 키 인덱스 확인
    2.  정렬여부 확인 정리
19. 3
    1.  1
        1.  IOT는 테이블 인덱스 구조로 관리함
        2.  힙 구조 테이블은 값을 무작위로 입력하지마 IOT는 지정한 키 값 순으로 정렬 상태를 유지함
        3.  클러스터는 값이 같은 레코드를 한 블록에 모아서 저장하믕로 인덱스를 이용한 테이블 랜덤 액세스를 줄이는데 도움을 줌
        4.  테이블 파티션은 사용자가 지정한 기준에 따라 데이터를 세그먼트 단위로 모아서 저장
        5.  
20. 2
    1.  4
    2.  
21. 4
    1.  2
    2.  PK 컬럼으로 IOT를 정의해야 하지만, SQL Server 클러스터형 인덱스는 PK 가 아닌 컬럼으로 생성할 수 있음
    3.  클러스터형 인덱스는 데이터를 정렬하는 기준을 정의하는 기능이므로 테이블에 한개만 생성됨
22. 2
    1.  4
        1.  중간값 검색으로 range scan 안됨
        2.  부정형 비교조건으로도 안됨
        3.  인덱스 컬럼을 변형하면 인덱스를 Range SCan 할 수 없음
        4.  수직적 탐색이 가능하므로 index range scan도 가능함
23. 3
    1.  
24. 2
    1.  4
    2.  숫자형과 문자형 비교할때 숫자 기준으로 문자형으로 자동 변환됨
    3.  숫자형과 문자형을 빅ㅛ할때 like 절 변경 시 문자형 기준으로 숫자형 컬럼이 변환됨
    4.  
25. 4
    1.  인덱스를 range scan 하려면 인덱스 선두커럼이 가공되지 않은 상태로 조건절에 있어야 함
    2.  반대로 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range scan은 무조건 가능함
    3.  range scan 한다고 해서 무조건 좋은건 아님
26. 4
    1.  3
    2.  or 조건은 기본적으로 index range scan을 위한 액세스 조건으로 사용할 수 없음
    3.  or 조건으로는 수직적 탐색을 통해 스캔 시작점을 찾을 수 없기 때문임
    4.  다만 concatenation(옵티마이저에 의한 union all 분기)으로 처리했을 때 각각 수직 탐색을 위한 액세스 조건으로 사용할 인덱스가 있다면 index range scan 이 가능함
27. 답
```
SELECT *
FROM 업체
WHERE 업체명 LIKE 대한용 :
SELECT *
FROM 사원
NHERE 월급여 >= 36000000 / 12;
SELECT *
FROM 주문
NHERE 주문수량>= 100;
SELECT *
FROM 주문
WHERE A| > TO_DATE( :dt, 'YYYYMNDD" )
AND A| < TO_DATE(:dt, 'YYYYMMDD') + 1:
SELECT *
FROM 주문
WHERE 할인율 < CEIL(:dcrt);
```

1.  답
```
select 주문번호, 주문일시, 고객ID, 총주문금액, 처리상태
from 주문
where 주문상태코드 in (select 주문상태코드
from
주문상태
where 주문상태코드 0 3)
and
주문일자 between :dt1 and :dt2
[ 모범답안 3 ]
select /*+ no_merge(a) ordered use_nl(b) */
주문번호, 주문일시, 고객ID, 총주문금액, 처리상태
from (select 주문상태코드
from 주문상태
where 주문상태코드 2 3) a, 주문 6
where b.주문상태코드 = a.주문상태코드
and
b. 주문일자 between :dt1 and :dt2
[ 모범답안 4]
select /*+ USE_CONCAT */
주문번호, 주문일시, 고객ID, 총주문금액, 처리상태
from
주문
where (주문상태코드 < 3 or 주문상태코드 > 3)
and
주문일자 between :dt1 and :dt2
[ 모범답안 5 ]
select 주문번호, 주문일시, 고객1D, 총주문금액, 처리상태
fron 주문
where 주문상태코드 < 3
and 주문일자 between :dt1 and :dt2
union all
select 주문번호, 주문일시, 고객1D, 총주문금액, 처리상태
fron 주문
where 주문상태코드 > 3
and
주문일자 between :dt1 and :dt2
```
1.  답 
```
UPDATE 월별계좌상태 SET 상태구분코드 = '07'
WHERE 상태구분코드 '01
AND 기준년월 = :BASE_DT
AND
(계좌번호, 계좌일련번호) IN (SELECT 계좌번호, 계좌일련번호
FROM 계좌원장
WHERE 개설일자 LIKE :STO_1 1| 8')

```
30. 
```
SELECT I*+ USE_CONCAT */ 거래일자 . SUN(DECODE(지수구분코드, 1', 지수종가,
0)) KOSPI200 IDX
. SUM(DECODE(지수구분코드, '1', 누적거래량, 0)) KOSPI200_IDX_TRDVOL , SU(DECODE(지수구분코드, 2', 지수종가, 0) KOSDACIOX , SUM(DECODE(지수구분코드, 2', 누적거래량, 0)) KOSDALLIOX_TROVOL
FRON 일별지수업종별거래 A WHERE 거래일자 BETWEEN :startod AND : endDd AND (지수구분코드, 지수업종코드) (('1', '001'), ('2', '003') )
GROUP BY 거래일자
[ 모범답안 2 ]
SELECT 거래일자
, SUM(DECODE(지수구분코드, 1', 지수종가, ) KOSP1200 IOX
• SUM(DECODE(지수구분코드, 1', 누적거래량, 0)) KOSPI200_IOXL TRDYOL , SUM(DECODE(지수구분코드, 2', 지수종가,
0)) KOSDAQ_IDX
, SUM(DECODE(지수구분코드, 2', 누적거래량, 8) KOSDAOLIDX_TROVOL
FROM 일별지수업종별거래 A WHERE 거래일자 BETWEEN :startDd AND : endod AND 지수구분코드 ='1'
AND 지수업종코드 = '001'
GROUP BY 거래일자
UNION ALL
SELECT 거래일자
, SUM(DECODE(지수구분코드, 1', 지수종가,
0)) KOSPI200_IDX
, SUM(DECODE(지수구분코드, 1', 누적거래량, 0)) KOSPI200_IDXL_TRDYOL , SUM(DECODE(지수구분코드, 2', 지수종가,
0)) KOSDAQ_IDX
, SUM(DECODE(지수구분코드, 2', 누적거래량, 01) KOSDAQLIDX_TROVOL
FROM 일별지수업종별거래 A WHERE 거래일자 BETWEEN :startDd AND :endDd AND 지수구분코드 = 2'
AND 지수업종코드 = '003'
GROUP BY 거래일자
```
31. 
```
SELECT NVL(MAX(주문번호) + 1, 1)
FROM
주문
WHERE
주문일자 = :주문일자
--> min max로 추가됨
```
32. 3
    1.  1
    2.  인덱스 rowid는 테이블 레코드를 찾아가기 위한 위치 정보일 뿐 테이블 레코드와 물리적으로 직접 연결된 구조는 아님
33. 4
    1.  클러스터링 팩터를 좋게하려면 테이블을 정렬 후 재생성말곤 없음
34. 3
    1.  3
    2.  데이터 양 대신에 인덱스를 이용한 테이블 액세스 비용과, 데이터 추출 건수가 많아질때 기하급수적으로 늘어난다 보면됨
35. 3
    1.  배치프로그램에서는 부분범위처리가 효용성이 없음
    2.  대량 배치에서는 전체범위에서 스캔을 하기 때문에 인덱스 부분범위처리가 효용성이 낮음
36. 2
    1.  ①번처럼 「사용여부 + 자동로밍여부 + 서비스번호, 로 변경하는 것이 쿼리 성능을 위해서 는 가장 최적이지만, 선두 컬럼을 변경했으므로 로밍렌탈_N2 인덱스를 사용하던 쿼리를 모 두 수집해서 성능 영향도를 검토해야만 한다.
    2.  ③번처럼 로밍렌탈 N2 인덱스 구성을 「사용여부 + 서비스번호」 로 변경하면 인덱스 스캔 효율은 다소 좋아지지만, 현재 가장 큰 문제인 테이블 랜덤 액세스를 줄이는 데는 전혀 도 움이 되지 않는다. 인덱스 컬럼 순서를 변경했으므로 영향도 검토도 필수다.
    3.  ④번처럼 「 사용여부 + 자동로밍여부 + 서비스번호」로 구성된 신규 인덱스를 생성하는 방 안도 고려해 볼 수 있으나, 인덱스 추가로 인해 DML 성능이 나빠지게 된다. 따라서 성능을 크게 향상시킬 수 있는 경우가 아니면, 가급적이면 인덱스를 추가하지 않고 기존 인덱스를 활용해 성능을 높이는 방안을 우선해서 고려해야 한다.
37. 4
    1.  3
    2.  인덱스를 재구성하면 스캔 비효율을 줄이는데는 좋지만, 테이블 액세스를 줄이는데는 도움이 안됨
    3.  테이블 랜덤 액세스가 많을 때는 인덱스 컬럼 추가를 가장 우선해서 검토한다.
    4.  ② IOT(인덱스 구조 테이블)가 테이블 랜덤 액세스를 없애는 데는 가장 효과적이다. 다만, 테이블 구조 변경에 따른 부담과 IOT 자체가 갖는 부작용이 적지 않으므로 운영 중에 적 용하고자 할 때는 신중하게 검토해야 한다.
    5.  ③ 인덱스를 재구성(Rebuild)하면 인덱스 스캔 비효율을 줄이는 데는 도움이 되지만, 테이 블 액세스를 줄이는 데는 전혀 도움이 되지 않는다.
    6.  ④ 인덱스 순으로 정렬되도록 테이블을 재생성한다면, 클러스터링 팩터가 좋아져 테이블 랜 덤 액세스를 줄이는 데 상당한 도움을 준다.
38. 4
    1.  인덱스 높이, 사이즈, 리프블록 I/O 증가
39. 4
    1.  batch io의 가능성이 있음
    2. 변경 후 실행계획에 BATCHED가 있다는건 배치 I/O가 작동할 수 있다는 의미이며 이 기능이 작동하더라도 SORT ORDER BY 오퍼레이션이 없는 한 부분범위 처리는 가능함  
40. 3
    1.  1
    2.  소트 연산을 생략할 수 없는 인덱스 구성이므로 sort order by는 생략이 됨
    3.  소트연산을 생략할 수 있는 인덱스 구성이어도 배치 I/O가 작동할 수 있다면 변경후 실행계획처럼 sort order by 오퍼레이션이 나타남
    4.  배치 I/O가 발생했을때 order by 를 이용해 정렬순서는 보장되나 부분범위처리가 불가능해짐
41. 2
    1.  4 
    2. 1 스캔한 블록이 8459개 한블록에 1000개가 있지만 10개를 얻기 위해 845백만개를 스캔
    3. 2 인덱스에서 얻은결과거눗만큼 10만번 액세스 후에 100개만 남음
    4. 3 10번 액세스 후에 모두 남았으므로 비효율은 아니나 ㅅ캔한 블록이 3647개이므로 비효율적임
    5. 5 10만번 액세스한 후 모두 남았으므로 비효율은 아님 스캔한 블록이 34522개중 428개이므로 스캔효율도 양호함
42. 1
    1.  3
    2.  인덱스 순서에 맞게 상품유형코드 다음에 업체유형코드가 조건절에 있었으면 비효율이 적게 스캔했을 것
43. 3,4
    1.  2,3
    2.  2 할인구분코드는 NDV가 적고 상품코드는 NDV가 많으므로 index skip scan이 매우 효과적임
    3.  3 선두컬럼이 적고 후행컬럼이 많을 때 between 선두컬럼을 in으로 바꾸면 성능향상에 도움이 됨
44. 1
    1.  4
    2.  in절에 추가된 쿼리로 인해 엑세스해야하는 테이블 수도 늘고 IN조건을 사용함으로 여러번 i/o가 발생하게 됨
45. 4
    1.  2
    2.  쿼리2상 승인요청일자의 값 종류가 7가지이고 매일 100만건이 있으므로 일자구간에서 특정 요청자 id를 찾을떄 skip scan이 좋다
    3.  쿼리 1에서는 승인요청일자로 갖는 값의 종류가 60만여개이므로 특정 구간에서 id를 찾을때 성능향상에 도움이안됨
46. 1
    1.  2,3 처럼 상품ID를 선두에 두면 ID에 대한 IN조건을 IN-LIST Iterator방식으로 풀어야 Index Range Scan이 가능함
    2.  그러면 인덱스 수직 탐색을 네번 해야 하므로 인덱스 높이가 3이면최소한 12개 블록을 ㅇ릭어야 횜
    3.  4번도 In list iteraotr 방식으로 12개는 읽어야 됨
    4.  고객번호와 주문일자 조건을 만족하는 데이터를 스캔하면서 상품 ID를 조건에 필터링하면 한 고객이 주문당 평균 20개상품을 구매하기 때문에 주문상세 레코드는 20개에 불과함 인덱스 높이가 3개면 3개 블록만 읽으면 됨
47. 4
    1.  3
    2.  1번은 맞는 인덱스가 없으므로 full scan하게 됨
    3.  24는 인덱스 수직탐색을 3번 해야함
48. 답
```
    1. 인덱스 추가를 통한 튜닝
증서번호+ 투입인출구분코드 + 이체사유발생일자 (+ 거래코드)
또는
투입인출구분코드 + 증서번호 + 이체사유발생일자 (+ 거래코드)
※ 거래코드 NOT IN 조건을 만족하는 데이터가 적다면, 거래코드를 인덱스 뒤쪽에 추가하는 것이 좋다. 테이블 랜덤 액세스를 그만큼 많이 줄여주기 때문이다. 거래코드 NOT IN 조건을 만족하는 데이터가 대다수라면 굳이 인덱스에 추가하지 않는 것이 좋다. 인덱스 사이즈를 줄이고, DML 성능을 좋게 하기 위해서다.
2. SQL 변경을 통한 튜닝
SELECT (G_기본이체금액 + G_정산이자)-(S_기본이체금액+ S_정산이자)
FROM (
SELECT NVL(SUM(CASE WHEN 투입인출구분코드 ='G' THEN 기본이체금액 END), 0) G_기본이체금액 
, NVL(SUM(CASE WHEN 투입인출구분코드 = 'G' THEN 정산이자 END), 0) G_정산이자
, NVL(SUM(CASE WHEN 투입인출구분코드 ='G' THEN 기본이체금액 END), G> S_기본이체금액 
, NVL(SUM(CASE WHEN 투입인출구분코드 ='S' EN 정산이자 END), 0) S_정산이자
FROM
거래
WHERE 증서번호 = : 증서번호
AND
이체사유발생일자 《= :일자
AND
거래코드 NOT IN ('7411','7412','7593','7584'")
AND
투입인출구분코드 IN ('G', 'S' )
```

49. 4
    1.  고객 id 변수에 아무것도 넣지 않았을 경우 full scan을 무조건 한번 돌고 between 절이 돌아가게됨
50. 3
    1.  1은 or 사용시 range scan이 발생함
    2.  2 like조건에 변수 미입력시 range scan일발생함
    3.  4 case사용 시 union all 형태로 쿼리변환 일어나지 않음
51. 4
    1.  1
    2.  조건절나열은 sql 성능과 무관함
    3.  
52. 4
    1.  조건의 연산자 둘다 =이므로 어떤 선두든 성능은 똑같음
53. 상품코드 + 거래일자 + 공급거래코드 순으로 인덱스를 만듬
    1.  =조건을 선두에 놓고 between 등 범위조건절은 뒤쪽으로 밈
54. 3
    1.  4
    2.  먼저 between을 후순위로 두는 것이 좋고 =조건절 중 가장 항목수가 적을 것으로 예상되는것이 등록지점이므로, 성별보단 등록지점을 앞에 두는 것이 좋다 판단, 그리고 4번의 경우는 블록의 i/o가 나머지 3개 구성보다 많을 것으로 예상됨
55. 4
    1.  3
    2.  = 조건절 대신 In조건절이 있기 때문에 등록쇼핑몰이 가장 먼저 갈것이고 뒤로부터는 가장 선택도가 낮은 항목을 선택한다.
    3.  따라서 선택도가 낮을 등록일자, 전화번호로 구성하는 것이 최적(자릿수)
56. 3
    1.  고객번호 뒤 거래일자가 붙는 것은 1,3쿼리의 조회조건이 고객번호 + 거래일자가 붙기 때문
    2.  2쿼리의 상품번호를 중간에 안넣고도 최적인 이유는 조회조건 순서에는 크게 영향이 없기 때문
57. 2
    1.  가장 앞에 와야하는 후보에 대해서만 실행계획에 조회
58. 3
    1.  인덱스 구성 국룰
    2.  = 연산자로 사용한 조건절, order by 기술한 컬럼 = 연산자 아닌애들은 데이터 분포에 따라 고려
    3.  답 3
59. 청약일자 입력일자 계약상태코드
    1.  취급지점 id 청약일자 입력자 id
60. 거래일자 + 계좌번호
    1.  x4
    2.  
61. 고객 id + 종료일자 + 연락처 구분 