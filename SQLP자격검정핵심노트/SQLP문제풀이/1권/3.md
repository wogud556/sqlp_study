1. 4
   1. 2
   2. 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미함
   3. 따라서 블록 첫번째 로우의 키 값과 일치하지 않을 수 없음
2. 4
   1. 1
   2. 테이블 스페이스는 ROWID 구조가 아님
3. 4
4. 2
   1. 4
   2. 가입일자 + 고객명을 선두로 갖는 인덱스가 없어 4번힌트는 무시됨
5. 3
   1. with 절 사용시 2,3번을 활용한다
   2. 클러스터형 인덱스가 없는 상황에서 index(0)을 지정하면 테이블 full scan 하면서 조건절을 필터링하며 index(1)을 지정하면 구문 오류가 발생함
6. 3
   1. 2
7. 2
   1. inde range scan 시 인덱스의 선두컬럼에 대한 조건이 반드시 있어야 하지만, '=' 조건일 필요는 없음, 부등호 BETWEEN LIKE등 모두 가능함
8. 2
   1. 4
   2. 오라클은 INDEX_FS 힌트를 제공하지 않음.
   3. index 힌트로 지정한 인덱스 선두 컬럼이 조건절에 없으면 INDEX FULL SCAN이 자동 선택되므로 별도 힌트가 필요하지 않음.
9.  4
    1.  2
    2.  PK 인덱스는 Unique함.
    3.  Unique 인덱스 구성 컬럼을 모두 = 조건으로 검색하면 index unique scan이 선택되지만 전체가 아닌 일부 컬럼으로 검색할 때는 Range scan이 선택됨
10. 4
    1.  1
    2.  인덱스 리프 블록들은 물리적으로는 여러 익스텐트에 흩어진 상태로 저장됨
    3.  하지만 정렬 순서에 따라 이중연결리스트(double linked list) 방식으로 서로 연결돼 있으므로 순서대로 스캔하면 결과 집합의 순서를 보장함
    4.  index full scan은 인덱스 리프 블록끼리의 논리적인 연결 순서를 따르지 않고
11. 1
    1.  2
    2.  조건절에 누락된 인덱스 선두 컬럼의 IN 조건절을 추가해주는 튜닝 기법과 용도는 비슷하지만 인덱스 스캔 원리는 다름
    3.  옵티마이저는 in 방식으로 강제로 처리할 수 없는 의미
12. 1
    1.  3
    2.  두 인덱스의 선투컬럼이 조건절에 없으므로 index range scan은 불가능함
    3.  인덱스에 없는 컬럼을 포함하므로 index fast full scan은 불가능함
13. 3
    1.  4
    2. 고객_PK를 사용하도록 힌트로 유도하면 고객번호가 조건절에 없으므로 index full scan하게 됨
    3. 고객_X01를 사용하면 선두컬럼인 연령이 조건절에 있으므로 index range scan이 가능함
    4. index skip scan도 가능하며, 고객 중 동명이인이 거의 없다면 range scan보다 skip scan이 유리함
    5. 즉 index range scan, index skip scan, index full scan 모두 가능함
14. 1
    1.  3
    2.  in 절에서 skipscan 이 안도는 이유
    3.  Skip Scan은 인덱스의 선두 컬럼에 대한 조건이 없을 때, 후행 컬럼 조건을 활용하여 인덱스를 반복적으로 탐색하는 방식입니다.
    4.  즉, 선두 컬럼이 없어도 후행 컬럼 조건을 이용해 “반복적으로 스캔”하는 방식(마치 선두 컬럼의 값들을 루프 돌리듯)

15. 4 -> 2,3
    1.  1
    2.  index  skew는 인덱스 엔트리가 왼쪽 또는 오른쪽으로 치우치는 현상
    3.  index sparse는 인덱스 블록 전반에 걸쳐 밀도가 떨어지는 현상을 말함
16. 1
    1.  2
    2.  비트맵 인덱스는 주로 읽기 위주의 대용량 DW환경에서 사용함
17. 3
    1.  조건절에서 인덱스 컬럼에 함수를 적용하면 정상적인 index range scan이 불가능함
    2.  인덱스에는 가공하지 않은 값을 기준으로 정렬해서 저장했는데, 가공한 값으로 검색하면 수직적 탐색을 통해 스캔 시작점과 끝 지점을 찾을 수 없기 때문임
    3.  아래 함수 기반 인덱스 생성시 문제 sql 도 index range scan이 가능함
18. 4
    1.  리버스 키 인덱스 확인
    2.  정렬여부 확인 정리
19. 3
    1.  1
        1.  IOT는 테이블 인덱스 구조로 관리함
        2.  힙 구조 테이블은 값을 무작위로 입력하지마 IOT는 지정한 키 값 순으로 정렬 상태를 유지함
        3.  클러스터는 값이 같은 레코드를 한 블록에 모아서 저장하믕로 인덱스를 이용한 테이블 랜덤 액세스를 줄이는데 도움을 줌
        4.  테이블 파티션은 사용자가 지정한 기준에 따라 데이터를 세그먼트 단위로 모아서 저장
        5.  
20. 2
    1.  4
    2.  
21. 4
    1.  2
    2.  PK 컬럼으로 IOT를 정의해야 하지만, SQL Server 클러스터형 인덱스는 PK 가 아닌 컬럼으로 생성할 수 있음
    3.  클러스터형 인덱스는 데이터를 정렬하는 기준을 정의하는 기능이므로 테이블에 한개만 생성됨
22. 2
    1.  4
        1.  중간값 검색으로 range scan 안됨
        2.  부정형 비교조건으로도 안됨
        3.  인덱스 컬럼을 변형하면 인덱스를 Range SCan 할 수 없음
        4.  수직적 탐색이 가능하므로 index range scan도 가능함
23. 3
    1.  
24. 2
    1.  4
    2.  숫자형과 문자형 비교할때 숫자 기준으로 문자형으로 자동 변환됨
    3.  숫자형과 문자형을 빅ㅛ할때 like 절 변경 시 문자형 기준으로 숫자형 컬럼이 변환됨
    4.  
25. 4
    1.  인덱스를 range scan 하려면 인덱스 선두커럼이 가공되지 않은 상태로 조건절에 있어야 함
    2.  반대로 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range scan은 무조건 가능함
    3.  range scan 한다고 해서 무조건 좋은건 아님
26. 4
    1.  3
    2.  or 조건은 기본적으로 index range scan을 위한 액세스 조건으로 사용할 수 없음
    3.  or 조건으로는 수직적 탐색을 통해 스캔 시작점을 찾을 수 없기 때문임
    4.  다만 concatenation(옵티마이저에 의한 union all 분기)으로 처리했을 때 각각 수직 탐색을 위한 액세스 조건으로 사용할 인덱스가 있다면 index range scan 이 가능함
27. 답
```
SELECT *
FROM 업체
WHERE 업체명 LIKE 대한용 :
SELECT *
FROM 사원
NHERE 월급여 >= 36000000 / 12;
SELECT *
FROM 주문
NHERE 주문수량>= 100;
SELECT *
FROM 주문
WHERE A| > TO_DATE( :dt, 'YYYYMNDD" )
AND A| < TO_DATE(:dt, 'YYYYMMDD') + 1:
SELECT *
FROM 주문
WHERE 할인율 < CEIL(:dcrt);
```

1.  답
```
select 주문번호, 주문일시, 고객ID, 총주문금액, 처리상태
from 주문
where 주문상태코드 in (select 주문상태코드
from
주문상태
where 주문상태코드 0 3)
and
주문일자 between :dt1 and :dt2
[ 모범답안 3 ]
select /*+ no_merge(a) ordered use_nl(b) */
주문번호, 주문일시, 고객ID, 총주문금액, 처리상태
from (select 주문상태코드
from 주문상태
where 주문상태코드 2 3) a, 주문 6
where b.주문상태코드 = a.주문상태코드
and
b. 주문일자 between :dt1 and :dt2
[ 모범답안 4]
select /*+ USE_CONCAT */
주문번호, 주문일시, 고객ID, 총주문금액, 처리상태
from
주문
where (주문상태코드 < 3 or 주문상태코드 > 3)
and
주문일자 between :dt1 and :dt2
[ 모범답안 5 ]
select 주문번호, 주문일시, 고객1D, 총주문금액, 처리상태
fron 주문
where 주문상태코드 < 3
and 주문일자 between :dt1 and :dt2
union all
select 주문번호, 주문일시, 고객1D, 총주문금액, 처리상태
fron 주문
where 주문상태코드 > 3
and
주문일자 between :dt1 and :dt2
```
1.  답 
```
UPDATE 월별계좌상태 SET 상태구분코드 = '07'
WHERE 상태구분코드 '01
AND 기준년월 = :BASE_DT
AND
(계좌번호, 계좌일련번호) IN (SELECT 계좌번호, 계좌일련번호
FROM 계좌원장
WHERE 개설일자 LIKE :STO_1 1| 8')

```
30. 
```
SELECT I*+ USE_CONCAT */ 거래일자 . SUN(DECODE(지수구분코드, 1', 지수종가,
0)) KOSPI200 IDX
. SUM(DECODE(지수구분코드, '1', 누적거래량, 0)) KOSPI200_IDX_TRDVOL , SU(DECODE(지수구분코드, 2', 지수종가, 0) KOSDACIOX , SUM(DECODE(지수구분코드, 2', 누적거래량, 0)) KOSDALLIOX_TROVOL
FRON 일별지수업종별거래 A WHERE 거래일자 BETWEEN :startod AND : endDd AND (지수구분코드, 지수업종코드) (('1', '001'), ('2', '003') )
GROUP BY 거래일자
[ 모범답안 2 ]
SELECT 거래일자
, SUM(DECODE(지수구분코드, 1', 지수종가, ) KOSP1200 IOX
• SUM(DECODE(지수구분코드, 1', 누적거래량, 0)) KOSPI200_IOXL TRDYOL , SUM(DECODE(지수구분코드, 2', 지수종가,
0)) KOSDAQ_IDX
, SUM(DECODE(지수구분코드, 2', 누적거래량, 8) KOSDAOLIDX_TROVOL
FROM 일별지수업종별거래 A WHERE 거래일자 BETWEEN :startDd AND : endod AND 지수구분코드 ='1'
AND 지수업종코드 = '001'
GROUP BY 거래일자
UNION ALL
SELECT 거래일자
, SUM(DECODE(지수구분코드, 1', 지수종가,
0)) KOSPI200_IDX
, SUM(DECODE(지수구분코드, 1', 누적거래량, 0)) KOSPI200_IDXL_TRDYOL , SUM(DECODE(지수구분코드, 2', 지수종가,
0)) KOSDAQ_IDX
, SUM(DECODE(지수구분코드, 2', 누적거래량, 01) KOSDAQLIDX_TROVOL
FROM 일별지수업종별거래 A WHERE 거래일자 BETWEEN :startDd AND :endDd AND 지수구분코드 = 2'
AND 지수업종코드 = '003'
GROUP BY 거래일자
```
31. 
```
SELECT NVL(MAX(주문번호) + 1, 1)
FROM
주문
WHERE
주문일자 = :주문일자
--> min max로 추가됨
```
32. 3
    1.  1
    2.  인덱스 rowid는 테이블 레코드를 찾아가기 위한 위치 정보일 뿐 테이블 레코드와 물리적으로 직접 연결된 구조는 아님
33. 4
    1.  클러스터링 팩터를 좋게하려면 테이블을 정렬 후 재생성말곤 없음
34. 3
    1.  3
35. 3
    1.  배치프로그램에서는 부분범위처리가 효용성이 없음
36. 2
37. 4
    1.  3
    2.  인덱스를 재구성하면 스캔 비효율을 줄이는데는 좋지만, 테이블 액세스를 줄이는데는 도움이 안됨
38. 4
39. 4
    1.  
40. 3
    1.  1
41. 2
    1.  4 
42. 1
43. 3,4
44. 1
45. 4
46. 1
47. 4
48. .
49. 4
50. 3
51. 4
52. 4
53. 상품코드 + 공급거래코드 + 거래일자 순으로 인덱스를 만듬
54. 3
55. 4
56. 3
57. 2
58. 3
59. 청약일자 입력일자 계약상태코드
60. 거래일자 + 계좌번호
61. 