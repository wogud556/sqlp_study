## 2. SQL 공유 및 재사용
- 소프트 파싱과 하드 파싱의 차이점

### 소프트 파싱 VS 하드 파싱
- 라이블리 캐시(Library Cache)
  - SQL파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 메모리 공간.
- SGA(System Global Area)
  - 서버 프로세스와 백그라운드 프로세스가 공통으로 엑서스하는 데이터와 제어 구조를 캐싱하는 메모리 공간([그림 1-4]: p29).

#### 소프트 파싱(Soft Parsing)
  - SQL을 캐시에서 찾아 곧바로 실행단계로 넘어가는 것.

#### 하드 파싱(Hard Parsing)
  - SQL을 캐시에서 찾는 것을 실패해 최적화 및 로우 소스 생성 단계까지 모두 거치는 것. (CPU 자원을 많이 소비하여 시스템 부하를 가져올 수 있음)

#### 소프트파싱 VS 하드파싱 FLOW
  <img src = "../img/1.png">

#### 최적화 과정이 Hard 한 이유
- 무수히 많은 경우의 수를 다 따져서 가장 좋은 결과를 얻을 수 있는 결과물을 가져오기 때문에 Hard함

#### 하드파싱 과정에서 옵티마이저가 사용하는 정보
- 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
- 오브젝트 통계
 - 테이블 통계, 인덱스 통계, (히스토그램을 포함한) 컬럼 통계
- 시스템 통계
 - CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
- 옵티마이저 관련 파라미터

### 바인드 변수의 중요성

#### 이름없는 SQL 문제
- 사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖고 컴파일 한 상태로 딕션너리에 저장
- 사용자가 삭제하지 않는 한 영구적으로 보관
- 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용. 
- 반면, SQL은 이름이 따로 없고, 전체 SQL 텍스트가 이름 역할을 함
- 처음 실행할 때 최적화 과정을 거쳐 동적으로 생성한 내부 프로시져를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용. 
- 캐시 공간이 부족하면 버려졌다가 다음에 다시 실행할 때 똑 같은 최적화 과정을 거쳐 캐시에 적재하는 하드 파싱 과정을 반복. 

#### 공유 가능 SQL
- 하나의 프로시저를 생성하여 SQL 옵티마이저와 로우 소스 생성기가 동일 기능을 하는 이름 없는 SQL을 실행 하면서 생성하는 내부 프로시저를 만드는 과정을 없앰
- DB I/O시 동시다발적으로 발생하는 하드파싱을 최대한 줄이는 방식으로 바인드 변수를 최대한 활용하게 한다.


