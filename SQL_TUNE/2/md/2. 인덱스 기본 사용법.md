## 2 인덱 기본 사용법
- 일단 표를 보자

|Index Range Scan이 가능한경우|Index Range Scan이 불가능 한 경우|
|--|--|
|- Index가 정렬되어 순서대로 정렬되어 있다. </br> - 단어들이 모여있다.|- 시작점을 찾을 수 없다. </br> - 가공 값이나 중간 값으로는 스캔 시작점을 찾을 수 없다. </br> - 가공 값과 중간 값으로는 색인 사용 시 색인 전체를 스캔해야 한다.

### 1. 인덱스를 사용한다는 것
- 인덱스 컬럼(선두 컬럼)을 가공하지 않아야 인덱스를 정상적으로 사용 가능
- 인덱스를 정상적으로 사용한다. = 리프 블록 일부를 스캔하는 Index Range Scan 의미

### 2. 인덱스 Range Scan을 할 수 없는 이유?
- 인덱스 스캔 시작점을 찾을 수 없기 때문에 인덱스 컬럼을 가공하면 정상적으로 사용이 안됨

#### 조건절에 따른 Range Scan이 불가능한 이유
- 기본적인 조건절에서 대부분은 스캔 시작점과 끝 지점을 알 수 없으므로 Range scan이 불가능함
- LIKE로 중간값 검색으로 포함하는 값은 전체 구간에 걸쳐 흩어져 있기 때문
- OR 조건절을 사용할 때 수직적 탐색으로 통해 특정 값을 한 시작지점으로 바로 찾을 수가 없음
  - 다만 UNION ALL을 이용하여 IN, OR을 대체한다
  - 이때 UNION ALL을 이요하여 각 브랜치 별로 인덱스 스캔 시작점 찾기가 가능하다.
- 그럼에도 Index Range Scan이 불가능한 경우
  - OR, IN조건은 옵티마이저에 의해 쿼리 변환 기능으로 Index Range Scan으로 처리되기도 한다.

### 3. 인덱스 사용 조건
- 인덱스 선두 컬럼이 조건절에 있어야 한다. <b>가공하지 않은 상태로</b>
- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있을 경우 Index Range Scan은 무조건 가능

#### 인덱스를 잘탄다
- 인덱스를 탄다는 표현은 인덱스를 Range Scan한다과 똑같은 의미
- 인덱스를 잘탄다 = 인덱스 리프 블록이 스캔하는 양이 작다. -> 인덱스 스캔 효율화 참고
- 스캔 범위가 좁아져야 인덱스를 잘탄다고 이야기할 수 있음

#### 인덱스를 이용한 소트 연산 생략 -> 5.3참고
- 인덱스가 정렬되어 있다. = 데이터도 정렬되어 있음 = Range Scan 가능
- ORDER BY 정렬 연산 생략 = 결과 집합은 어차피 변경 순번순으로 정렬되기 때문.


### 5. ORDER BY 절에서 컬럼 가공 - 98~99P SQL 참고하자
- 가공값 기준으로 정렬 요청 시 생략 불가능

### 6. SELECT-LIST 컬럼 가공
- 최소값 MIN - 옵티마이저는 정렬 연산 수행 안함/ 가장 왼쪽 첫번째 레코드가 최소값
- 최대값 MAX - 오른쪽 레코드 하나만 읽는다.
- 인덱스는 문자열 기준 정렬 = 숫자형으로 형변환 시 생략 불가능
- 인덱스 컬럼 가공 시 표과적인 SQL작성하기 - TOP N 알고리즘(5.3.4 이력 조회)

### 7. 자동 형변환
- 옵티마이저가 SQL을 자동으로 변환 -> 인덱스 컬럼이 가공됨
- 문자형 < 숫자형(숫자형 컬럼 기준으로 문자형 컬럼을 변환)
- 날짜 포맷을 정확히 지정하여 코딩(컴파일 오류나 결과집합이 달라질 수 있다.)
- 숫자형 컬럼 LIKE 검색 시 자동 형변환이 발생하여 인덱스 액새스 조건으로 사용 불가
- 운자형 컬럼이 숫자형으로 변환되는 데 문자형 컬럼에 숫자로 변환할 수 없는 문자열이 입력되면 쿼리 수행 도중 에러가 발생한다.
- Decode 형변환으로 인한 오류 조심 (데이터 타입 일치 시 오류 해결)
- 자동 형변환에 의존하지 말고 인덱스 컬럼 기준으로 값을 정확히 형변환
- SQL 성능 - 블록 I/O를 줄일 수 있는냐 없느냐가 중요하다.
- 형변환 함수를 생략해도 옵티마이저가 자동으로 생성
