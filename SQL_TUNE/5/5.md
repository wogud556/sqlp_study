5
## 5장 소트 튜닝
## 5.1. 소트 연산에 대한 이해
### 5.1.1 소트 수행 과정
- 오라클 서버 프로세스는 SGA(System Global Area)에 공유된 데이터를 읽고 쓰면서, 동시에 자신만의 고유 메모리 영역인 PGA(Private Global Area)를 갖는다.
- 사진 추가 예정
- SGA
  - 모든 사용자가 공유 가능하여 사용
- PGA
  - 사용자마다 공유하지 않고 개별적으로 사용
- 사진 추가 예정
- 소트는 PGA에 할당한 정렬 공간에서 이루어짐. 정렬 공간이 차면 디스크 Temp 테이블스페이스를 활용
- 메모리 소트(In-Memory Sort)
  - 전체 데이터의 정렬 작업을 메모리 내에서 완료하는 것
- 디스크 소트(To-Disk Sort)
  - 할당받은 정렬 공간 내에서 정렬을 완료하지 못해 디스크 공간까지 사용하는 경우
### 디스크 소트 과정
- 사진추가예정
1. 소트할 대상 집합 SGA 버퍼캐시를 통해 읽기
2. Sort Area에서 정렬 시도
3. Sort Area 내에서 데이터 정렬을 마무리하거나 양이 많을 때는 정렬된 중간집합을 Temp 테이블’ 스페이스에 임시 세그먼트를 만들어 저장(이때, Temp 영역에 저장해 둔 중간 단계의 집합을 ‘Sort Runs’이라 함)
4. 정렬된 최종 결과집합을 얻기 위해 Merge
   - 소트 연산 -> 메모리 집약적, CPU 집약적
   - 처리할 데이터량이 많을 경우 디스크 I/O까지 발생하므로 쿼리 성능을 좌우하는 중요한 요소
   - 디스크 소트는 부분범위 처리를 불가능하게 함으로써 OLTP 환경에서 애플리케이션 성능 저하시키는 주요인
   => 소트가 발생하지 않도록 SQL 작성, 소트가 불가피하다면 메모리 내에서 수행 완료할 수 있도록
      한다.
### 5.1.2 소트 오퍼레이션
#### Sort Aggregate
- 전체 로우를 대상으로 집계를 수행할 때 나타남
- Sort 표현을 사용하지만 실제로 데이터를 정렬하지 않는다. Sort Area를 사용한다는 의미!
- 사진추가예정
#### 데이터를 정렬하지 않고 SUM, MAX, MIN, AVG 값 구하는 과정
1. Sort Area에 SUM, MAX, MIN, COUNT 값을 위한 변수 할당
2. EMP 테이블 첫번째 레코드에서 읽은 값을 변수에 저장, COUNT 변수에는 1 저장
3. EMP 테이블에서 레코드를 하나씩 읽어가면서 SUM 변수에 값 누적, MAX 변수에는 기존보다 큰 값 나타나면 대체, MIN 변수에는 기존보다 작은 값 나타나면 대체, COUNT 변수에는 값이 NULL이 아닌 레코드를 만날 떄마다 1 증가
4. EMP 테이블을 다 읽고 SUM, MAX, MIN 값은 그대로 출력, AVG는 SUM 값을 COUNT 값으로 	   나눔
#### Sort Order By
- 데이터 정렬할 때 나타남
#### Sort Group By
- 소팅 알고리즘을 사용해 그룹별 집계 수행할 때 나타남
- EMP 테이블에서 부서코드(10, 20, 30, 40)별로 급여 집계
- 사진 추가 에정

1. 부서코드별로 SUM, MAX, MIN, COUNT 변수 할당
2. 각 사원의 급여 정보를 읽어 각 사원의 부서번호에 해당하는 부분을 찾아 SUM, MAX, MIN, COUNT 값 갱신
3. Sort Aggregate에서 사용했던 방식과 똑같이 수행
> 부서가 많지 않다면 Sort Area가 클 필요 없음. 집계할 대상 레코드가 많아도 Temp는 쓰지 않는다!

#### * Hash Group By *
- 오라클 10gR2 버전에 도입된 방식
- Group By 절 뒤에 Order By 절을 명시하지 않으면 Hash Group By 방식으로 처리
- 소트 알고리즘이 아닌 해싱 알고리즘을 사용
- 읽는 레코드마다 Group By 컬럼의 해시 값으로 해시 버킷을 찾아 그룹별로 값을 갱신.
#### ※ 그룹핑 결과의 정렬 순서 ※
- 오라클은 그룹핑 결과가 정렬 순서를 보장하지 않는다고 공식적으로 밝혔음
- 실행계획에서 ‘Sort Group By’의 의미는 소팅 알고리즘을 사용해 값을 집계한다는 뜻일 뿐 결과의 정렬을 의미하지 않는다. 쿼리에 Order By 절을 명시했을 경우에는 정렬 순서가 보장된다. 
- 이때도 실행계획에는 ‘Sort Group By’로 표시되므로 실행계획만 보고 정렬 여부 판단 X
- 즉, 정렬된 그룹핑 결과를 얻고자 한다면 반드시 Order By 명시!
#### Sort Unique
- Unnesting 된 서브쿼리가 메인 쿼리와 조인하기 전에 중복 레코드를 제거할 때 나타남.
- PK/Unique 제약 또는 Unique 인덱스를 통해 Unnesting 된 서브쿼리의 유일성이 보장되면, Sort Unique 오퍼레이션 생략
- Union, Minus, Intersect 같은 집합 연산자, Distinct 연산자 사용할 때도 나타남
#### Sort Join
- 소트 머지 조인 수행할 때 나타남
- 사진 추가
#### Window Sort
- 윈도우 함수(=분석 함수)를 수행할 때 나타남
- 윈도우 함수
  - 행과 행간의 관계를 쉽게 정의하기 위해 만든 함수로 순위함수(RANK, DENSE_RANK, ROW_NUMBER)와 집계함수(SUM, MAX, MIN, AVG, COUNT) 와 같은 함수를 말한다

## 5.2. 소트가 발생하지 않도록 SQL 작성
### 5.2.1 Union vs Union All
- SQL에 Union을 사용하면 옵티마이저는 상단과 하단 두 집합 간 중복 제거 위해 소트 작업 수행. 
- 반면, Union All은 중복 확인하지 않고 두 집합 단순히 결합하므로 소트 작업 X
- 따라서 될 수 있으면 Union All을 사용! 
- But, Union을 Union All로 변경하려다가 결과 집합이 달라질 수 있으므로 주의
- ex 1) 사진 추가 예정
- 결제수단코드 조건절에 다른 값을 입력했기 때문에 상단과 하단 집합 사이에 중복 가능성 X
- Union을 사용함으로 인해 소트 연산 발생!
> 상호배타적이므로 Union 대신 Union All 사용가능!!!
- ex 2) 사진 추가 예정
- 이 쿼리는 상단과 하단 집합 사이에 중복 가능성 O
- 사진 추가 예정
- 결제일자와 주문일자 조건은 상호배타적 조건이 아니기 때문에 Union을 Union All로 변경하면, 결제일자와 주문일자가 같은 결제 데이터 중복 출력
- 사진 추가 예정
> 소트 연산이 일어나지 않게 하고, Union All을 사용하여 데이터 중복을 피하려면 이와 같은 쿼리 사용
### 5.2.2 Exists 활용
- 중복 레코드를 제거하려고 Distinct 연산자를 사용하면 모든 데이터를 읽어서 중복 제거해야 하므로 부분범위 처리 불가능, 모든 데이터를 읽는 과정에 많은 I/O 발생
- ex 1) 사진 추가 예정
- 상품유형코드 조건절에 해당하는 상품에 대해 계약일자 조건 기간에 발생한 계약 데이터 모두 읽는 비효율 발생
- 사진 추가 예정
- 쿼리를 이렇게 바꾸면 상품유형코드 조건절에 해당하는 상품에 대해 계약일자 조건 기간에 발생한 계약 중 계약구분코드에 만족하는 데이터가 존재하는지만 확인
- Distinct 연산자 사용하지 않았으므로 상품 테이블에 대한 부분범위 처리도 가능
* Minus 연산자는 위와 동일한 방식으로 Not Exists 서브쿼리로 변환해서 사용 가능

### 5.2.3 조인 방식 변경
- 조인문일 떄는 조인 방식을 잘 선택해야 함.
- 사진 추가 예정
- 계약_X01 인덱스를 타게 되면 소트 연산 생략할 수 있지만 해시 조인이기 때문에 Sort Order By 실행계획 나타남
- 사진 추가 예정
- leading(c) use_nl(p) 힌트를 사용하여 계약 테이블을 기준으로 상품 테이블과 NL조인하도록 조인 방식을 변경하면 소트 연산을 생략할 수 있음

## 5.3 인덱스를 이용한 소트 연산 생략

### 5.3.1 Sort Order By 생략
- 인덱스를 조건절에 알맞게 구성할 경우 sort 연산이 생략이 가능하다. 
- 소트 연산이 생략 되므로 조건을 만족하는 전체 레코드를 읽지 않고 바로 결과집합이 출력 가능하다. = 부분범위 처리가 가능하다. 
  - 3-Tier 아키텍처는 서버 리소스를 수많은 클라이언트가 공유하는 구조 = 클라이언트가 특정 DB 커넥션을 독점 불가 
- 사진하나 추가 예정
### 5.3.2 TopN 쿼리
-	결과 집합 중 상위 N개 레코드만 선택하는 쿼리 

```
ex) SQL Server, Sybase – select TOP 10 거래일시, 체결수량 …
ex) IBM DB2 – FETCH FIRST 10 ROWS ONLY 
ex) Oracle – 인라인 뷰
```
```
select * from (
  select 거래일시, 체결건수, 체결수량, 거래대금
  from 종목거래
  where 종목코드 = 'KR123456'
  and 거래일시 >= '20180304'
  order by 거래일시
)
where rownum <= 10
```
- 인덱스[종목코드 + 거래일시]
  - 구성시 옵티마이저가 소트 연산 생략
- 사진두장 추가예정

-	COUNT(STOPKEY) : ROWNUM으로 지정한 건수만큼 레코드 결과를 얻으면 멈춘다. 
  - Top N Stopkey 알고리즘 
-	페이징 처리에서 많이 사용
```
rownum <= ( :page * 10 ) 
rownum 제거시 Stopkey가 작동하지 않는다. = 전체범위 처리 
```
#### 부분범위 처리가 가능한 SQL 조건
- 인덱스를 사용하도록 조건절 작성
- 조인은 NL 조인 위주로 되도록
- Order by 가 있어도 소트 연산이 생략되도록 인덱스 구성 

### 5.3.3 최소값/최대값 구하기
-	인덱스를 사용하여 전체 데이터를 읽지 않고 최소, 최대값을 찾는다.
```
실행계획 - INDEX (FULL SCAN (MIN/MAX)) OF ‘EMP_X1’ (INDEX) (Cost=1 Card=1… )
```
- 오라클 8i 부터 등장 / 8버전 이전에는 인덱스가 있어도 풀 스캔을 함 
-	조건절과 MIN/MAX 함수 인자 컬럼이 모두 인덱스 포함돼야 한다. 
-	인덱스 선두 컬럼이 = 조건이여야 한다. 
  - 조건을 만족하는 범위(Range)의 가장 오른쪽 값을 하나 읽는다. 
#### First Row Stopkey 알고리즘
- FIRST ROW 조건을 만족하는 레코드를 하나 찾으면 멈춤
-	Top N 쿼리를 사용해 최소, 최대값을 구할 수 있다. 
-	ROWNUM <= 1 조건을 이용해 Top 1 레코드를 찾는다. 
  - 모든 컬럼이 인덱스에 없어도 작동 
  - MIN/MAX 쿼리보다 성능이 좋음 
- 사진 하나 추가 예정 
  - 완성된 페이징 처리 SQL
  - rownum 조건절 생략시 Sort Order By가 나타나지 않지만 Stopkey도 안나타난다. 
  - Stopkey가 없으면 전체 범위를 처리한다. 
 
### 5.3.4 이력조회
- 변경이력을 관리하기 위해 상태변경이력 테이블을 만든다. 
- 상태변경이력 테이블에는 과거 변경이력과 현재 데이터도 저장한다. 
>	이력 데이터 조회시 ‘First Row Stopkey’ 또는 ‘Top N Stopkey’ 알고리즘이 작동하도록 
인덱스 설계 및 SQL 구현해야 한다. 

- 인덱스 컬럼 가공시 ‘First Row Stopkey’ 알고리즘이 작동하지 않는다. 
>ex) 이력이 많을 경우 서브 쿼리를 3번 사용해서 
‘First Row Stopkey’ 알고리즘을 작동하게 하는 것이 더 효율이 좋다. 
- 사진 한장 추가 예정
>ex) INDEX_DESC 힌트를 사용하고, rownum <= 1 조건절을 사용하는 방식
>ex) 11g/12c 신기능 활용
```
11g - ‘Predicate Pushing’ 쿼리 변환 기능이 작동하도록
12c – 파싱 오류 없이 ‘Top N Stopkey’ 알고리즘이 작동한다. 
``` 
- 사진하나 추가 예정
-	전체(=많은) 장비 이력 조회 
  - Stopkey 작동여부가 핵심이 아닌, 전체를 빠르게 처리하는 것이 목표
  - ex) 윈도우 함수 이용
  - ex) KEEP절 활용
  - FROM MAX(상태코드) KEEP (DENSE_RANK LAST ORDER BT 변경일자, 변경순번) 변경순번
-	선분이력 모델
  - #변경일자 -> #유효시작일자, #유효종료일자
  - 선분이력 모델 사용시 간단한 쿼리로 이력 조회 가능 

### 5.3.5 Sort Group By 생략
- region이 선두 컬럼인 인덱스 사용시 Sort Group By 연산을 생략 가능
- 사진 두장 추가 예정

## 5.4. Sort Area를 적게 사용하도록 SQL 작성
- 소트 연산이 불가피하다면 메모리 내에서 처리를 완료할 수 있도록 Sort Area를 적게 사용할 수 있게 SQL 작성

### 5.4.1 소트 데이터 줄이기
- 『예제 1. 특정 기간에 발생한 주문상품 목록 산출 SQL Sort Area 사용 비교』
- 사진 하나 추가 예정 
- 1번의 경우 레코드당 가공한 결과집합을 Sort Area에 담는 반면, 2번의 경우 가공하지 않은 상태로 정렬을 완료하고 그 결과집합을 Sort Area 저장 후 최종 출력할 때 가공(Sort Area 에 저장되어 있는 데이터). => 2번 SQL이 Sort Area를 훨씬 적게 사용.

- 『예제 2. 조회 대상 컬럼의 수에 따른 SQL Sort Area 사용량 비교』
- 사진 하나 추가 예정
- 1번 SQL은 모든 컬럼을 Sort Area에 저장하는 반면, 2번 SQL은 계좌번호와 총예수금만 저장하기 때문에 2번 SQL이 적게 사용
- 성능 차이 발생(예제 [예수금원장] 테이블이 229개의 컬럼을 가지고 있다고 가정할 경우, 1번 SQL은 14.1초, 2번 SQL은 1.2초 소요 & 716M vs. 17M). 
>=> 조회 대상 컬럼이 적을수록 SQL Sort Area 에 저장할 데이터가 줄어들고 성능이 개선됨. 

### 5.4.2 Top N 쿼리의 소트 부하 경감 원리
- 인덱스로 소트 연산을 생략할 수 없을 때(Top N Stopkey 알고리즘 사용 불가 케이스), Top N 쿼리 동작 원리: Top N 소트 알고리즘.
- 『Top N 소트 알고리즘 동작원리 - 전교생 1,000명 중 가장 키 큰 학생 열 명 선발』 - p383
- 사진 하나 추가 예정 
  1. 대상 TABLE FULL SCAN.
  2. Top N 표본 데이터 임의 산출 및 선별 기준에 따른 정렬, 그리고 Sort Area 저장.
  3. 마지막 N 번째 데이터와 남은 데이터들을 선별 기준에 따라 비교, 남은 데이터들 중에서 선별 조건에 보다 부합하는 데이터가 있는 경우 해당 데이터를 기존 N 번째 자리 대체.
  4. Sort Area Top N 데이터 정렬.
  5. 남은 ① 번 TABLE FULL SCAN 데이터로 ③ 번, ④ 번 과정 반복.

#### Sort Order By 오퍼레이션: SORT ORDER BY STOPKEY
- Sort Order By 옆에 보이는 ‘Stopkey’ 키워드(‘SORT ORDER BY STOPKEY’)는 해당 SQL 실행 과정에서 소트 연산을 피할 수 없어 Sort Order by 오퍼레이션을 수행하지만 ‘Top N 소트’ 알고리즘이 작동한다는 것을 실행계획에 표시하는 것임.
- ‘Top N 소트’ 알고리즘이 작동: 소트 연산(=값 비교) 횟수와 Sort Area 사용량을 최소화.
- DISK상 Physical Read(=pr)와 Physical Write(=pw)가 발생하지 않음 – AutoTrace 확인.

- 『예제 3. 인덱스 소트 연산 vs. Table Full Scan 방식에 따른 Top N 쿼리 동작 방식 비교』
- 사진 한장 추가예정
- 예제3. 인덱스 소트 연산.                    - 예제3. Table Full Scan 방식.
- 사진 두장 더 추가예정

### 5.4.3 Top N 쿼리가 아닐 때 발생하는 소트 부하
- Order By 아래 ROWNUM 조건절 제거: p386 SQL & p.387 실행계획(STOPKEY 없음) 참조.
『AutoTrace 통해 살펴본 Top N 쿼리 적용 여부에 따른 성능 비교(p.385 vs. p387 참조)』
- Top N 쿼리 적용: sorted in momory area       - Top N 쿼리 적용 불가: sorted in disk area
- 사진 두장 추가예정
  
### 5.4.4 분석함수에서의 Top N 소트
- 윈도우 함수 중 Top N 소트 알고리즘이 작동할 경우 소트 부하가 적음
  - ‘rank()’ or ‘row_number()’ > ‘max()’ – rank(), row_number() 의 경우 max() 함수와 다르게 Top N 소트 알고리즘이 작동됨. 
- 『예제.4 상태변경이력 max vs. rank 사용 성능 비교 – p.388 참조』
- 사진하나 추가 예정  
- 왼쪽: ‘max(변경순번) over (partition by 장비번호) 최종변경순번’ 적용
- 오른쪽: ‘rank() over (partition by 장비번호 order by 변경순번 desc) rnum’ 적용

